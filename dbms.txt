Problem statement1. Consider following Bank database schema and solve given queries:
Account(Acc_no, branch_name,balance)
branch(branch_name,branch_city, assets)
customer(cust_name,cust_street,cust_city)
Depositor(cust_name,acc_no)
Loan(loan_no,branch_name,amount)
Borrower(cust_name,loan_no)
Q.1 Create above tables with appropriate constraints like primary key, foreign key, not null 
etc.
with suitable data
SQL> create table branch(branch_name char(20) primary key,branch_city char(20) , assets 
number);
Table created.
SQL> insert into branch values('Nigdi','Pune',10000000)
SQL> insert into branch values('Akurdi','Pune',50000000);
SQL> insert into branch values('Khed','Pune',70000000);
SQL> insert into branch values('Chinchwad','Pune',80000000);
SQL> insert into branch values('Wafgaon','Khed',30000000);
SQL> select * from branch;
BRANCH_NAME BRANCH_CITY ASSETS
-------------------- -------------------- ----------
Nigdi Pune 10000000
Akurdi Pune 50000000
Khed Pune 70000000
Chinchwad Pune 80000000
Wafgaon Khed 30000000
SQL> create table account(acc_no number primary key , branch_name char(20) references 
branch(branch_name) on delete set null ,balance number);
Table created.
SQL> insert into account values(1234567891,'Nigdi',10000);
SQL> insert into account values(1234567892,'Nigdi',20000);
SQL> insert into account values(1234567893,'Khed',30000);
SQL> insert into account values(1234567894,'Chinchwad',40000);
SQL> select * from account;
 ACC_NO BRANCH_NAME BALANCE
---------- -------------------- ----------
1234567891 Nigdi 10000
1234567892 Nigdi 20000
1234567893 Khed 30000
1234567894 Chinchwad 40000 SQL> create table customer(cust_name char(20) 
primary key,cust_street varchar(30),cust_city char(20) );
Table created.
SQL> insert into customer values(‘Harshad’,'khed','Pune');
SQL> insert into customer values('Aviraj','Nigdi11','Pune');
SQL> insert into customer values('Nayan','Nigdi12','Pune');
SQL> insert into customer values('Ashirwad','Nigdi13','Pandharpur');
SQL> insert into customer values('Aditesh','audh','Pune');
SQL> insert into customer values('Vedant','Khed','Pune');
SQL> insert into customer values('Aditya','Khed','Pune');
SQL> insert into customer values('Siddhesh','Kolhapur','Kolhapur');
SQL> insert into customer values('Rushi','Kolhapur','Kolhapur');
SQL> insert into customer values('Sarang','Satara','Satara');
SQL> select * from customer;
CUST_NAME CUST_STREET CUST_CITY
-------------------- ------------------------------ --------------------
Harshad Khed Pune
Aviraj Nigdi11 Pune
Nayan Nigdi12 Pune
Ashirwad Nigdi13 Pandharpur
Aditesh audh Pune
Vedant Khed Pune
Aditya Khed Pune
Siddhesh Kolhapur Kolhapur
Rushi Kolhapur Kolhapur
Sarang Satara Satara
10 rows selected.
SQL> create table depositor(cust_name char(20) references customer(cust_name) on delete 
cascade , acc_no number references account(acc_no) on delete set null);
Table created.
SQL> select * from depositor;
CUST_NAME ACC_NO
-------------------- ----------
Harshad 1234567891
Aviraj 1234567892
Nayan 1234567893
Ashirwad 1234567894
SQL> create table loan(loan_no number primary key,branch_name char(20) references 
branch(branch_name) on delete set null , amount number);
Table created.
SQL> select * from loan;
 LOAN_NO BRANCH_NAME AMOUNT
---------- -------------------- ----------
9874563211 Nigdi 200000
9874563212 Nigdi 300000
9874563213 Nigdi 400000
9874563214 Khed 350000
9874563215 Chinchwad 250000
SQL> create table borrower(customer_name char(20) references customer(cust_name)on 
delete cascade,loan_no number references loan(loan_no) on delete set null);
Table created.
SQL> select * from borrower;
CUSTOMER_NAME LOAN_NO
-------------------- ----------
Aditesh 9874563211
Vedant 9874563212
Aditya 9874563213
Rushi 9874563214
Q.2. Create synonym for customer table as cust.
SQL> create synonym cust for customer;
Synonym created.
Q.3 Add customer phone number in Customer table.
SQL> alter table customer add phone_no number(10);
Table altered.
Q.4 Delete phone number attribute from Customer table.
SQL> alter table customer drop column phone_no;
Table altered.
SQL> desc customer;
Name Null? Type
----------------------------------------- -------- ----------------------------
CUST_NAME NOT NULL CHAR(20)
CUST_STREET VARCHAR2(30)
CUST_CITY CHAR(20)
Q.5. Find the names of all branches in loan relation.
SQL> select distinct branch_name from loan;
BRANCH_NAME
--------------------
Nigdi
Khed
Chinchwad
Q.6. Find all customers who have a loan from bank. Find their names,loan_no and loan
amount.
SQL> select borrower.customer_name , borrower.loan_no , loan.amount from borrower,loan 
where borrower.loan_no = loan.loan_no;
CUSTOMER_NAME LOAN_NO AMOUNT
-------------------- ---------- ----------
Aditesh 9874563211 200000
Vedant 9874563212 300000
Aditya 9874563213 400000
Rushi 9874563214 350000
Q.7. List all customers in alphabetical order who have loan from Nigdi branch.
SQL> select customer_name from borrower where loan_no in (select loan_no from loan 
where branch_name = 'Nigdi') order by customer_name;
CUSTOMER_NAME
--------------------
Aditesh
Aditya
Vedant
Q.8. Find all customers who have an account or loan or both at bank.
SQL> SELECT cust_name FROM customer where cust_name IN(SELECT customer_name
FROM borrower INTERSECT SELECT cust_name FROM depositor);
CUST_NAME
--------------------
Rushi
Q.9. Find average account balance at Nigdi branch.
SQL> SELECT AVG(balance) AS avg_balance FROM account WHERE branch_name = 'Nigdi';
AVG_BALANCE
-----------
 15000
Q.10. Find no. of depositors at each branch.
SELECT branch_name, COUNT(*) AS num_depositors FROM depositor GROUP BY 
branch_name;
Q.11. Delete all tuples at every branch located in Nigdi.
DELETE FROM branch WHERE branch_city = 'Nigdi';
DELETE FROM account WHERE branch_name = 'Nigdi';
















Problem statement 2.
a) Consider following database schema and solve given queries
cust_mstr(cust_no,fname,lname)
add_dets(code_no,add1,add2,state,city,pincode)
1. Create above Tables with suitable data
2. Retrieve the address of customer Fname as 'xyz' and Lname as 'pqr'
3. Create View on add_dets table by selecting any two columns and perform insert
update delete operations
SQL> CREATE TABLE cust_mstr (
 2 cust_no INT PRIMARY KEY,
 3 fname VARCHAR(50),
 4 lname VARCHAR(50)
 5 );
Table created.
SQL> select * from cust_mstr;
 CUST_NO FNAME LNAME
---------- --------------------- -----------------------------
 1 Harshad Karale
 2 Rushikesh Magadum
 3 Sarang Kadam
SQL> CREATE TABLE add_dets (code_no INT references cust_mstr(cust_no),add1 
VARCHAR(100),add2 VARCHAR(100),state VARCHAR(50),city VARCHAR(50),pincode 
VARCHAR(10));
Table created.
SQL> INSERT INTO add_dets values(1,'Jaulke BK','Pargaon','Maharashtra','Khed',410512);
1 row created.
SQL> INSERT INTO add_dets values(2,'xyz','Kolhapur','Maharashtra','Kolhapur',410512);
1 row created
SQL> select * from add_dets where code_no IN ( select cust_no from cust_mstr where 
fname='Harshad' AND lname='Karale');
 1
Jaulke BK
Pargaon
Maharashtra
Khed 
410512
b) Create following Tables
emp_mstr(e_mpno,f_name,l_name,m_name,dept,desg,branch_no)
branch_mstr(name,b_no)
List the employee details along with branch names to which they belong
SQL> CREATE TABLE branch_mstr(name char(10),b_no number primary key);
Table created.
SQL> select * from branch_mstr;
NAME B_NO
---------- ----------
Computer 1
MECH 2
IT 3
Civil 4
SQL> CREATE TABLE emp_mstr(emp_no number NOT NULL,fname char(10),lname
char(10),mname char(10),dept char(10),desg char(10),branch_no number references
branch_mstr(b_no) on delete set null);
Table created.
SQL> select * from emp_mstr;
EMP_NO FNAME LNAME MNAME DEPT DESG BRANCH_NO
---------- ---------- ---------- ---------- ---------- ---------- ----------
1 Harshad Karale Sanjay Comp Student 1
SQL> select * from emp_mstr where branch_no IN(select b_no from branch_mstr where
name = 'Computer');
EMP_NO FNAME LNAME MNAME DEPT DESG BRANCH_NO
---------- ---------- ---------- ---------- ---------- ---------- ----------
1 Harshad Karale Sanjay Comp Student 1



















Problem statement3. Consider following Bank database schema and solve given queries:
Account(Acc_no, branch_name,balance)
branch(branch_name,branch_city, assets)
customer(cust_name,cust_street,cust_city)
Depositor(cust_name,acc_no)
Loan(loan_no,branch_name,amount)
Borrower(cust_name,loan_no)
Q.1 Create above tables with appropriate constraints like primary key, foreign key 
constrains, not
null etc. with suitable data
Q.2. Modify “assets” attribute of branch table to “Property”
SQL> ALTER TABLE branch RENAME COLUMN assets TO property;
Table altered.
Q.3. Find all loan numbers for loans made at Akurdi Branch with loan amount > 12000.
SQL> SELECT loan_no FROM loan WHERE branch_name = 'Nigdi' AND amount > 12000;
 LOAN_NO
----------
9874563211
9874563212
9874563213
Q.4. Find all customers who have both account and loan at bank.
SQL> SELECT cust_name FROM customer where cust_name IN(SELECT customer_name
FROM borrower INTERSECT SELECT cust_name FROM depositor);
CUST_NAME
--------------------
Rushi
Q.5. Find all customer who have account but no loan at the bank.
SQL> SELECT cust_name FROM customer where cust_name IN(SELECT customer_name
FROM borrower MINUS SELECT cust_name FROM depositor);
CUST_NAME
--------------------------------------------------
Aviraj
Rushi
Q.6. Find the average account balance at each branch
SQL> SELECT branch_name,AVG(balance) AS avg_balance FROM account Group by 
branch_name;
BRANCH_NAME AVG_BALANCE
-------------------- -----------
Nigdi 15000
Khed 30000
Chinchwad 40000
Q.7. Find the branches where average account balance > 12000.
Q11. Find the branches where average account balance > 12000.
SQL> SELECT AVG(balance),branch_name FROM account GROUP BY branch_name HAVING
AVG(balance)>20000;
AVG(BALANCE) BRANCH_NAME
------------ --------------------
30000 Khed
40000 Chinchwad
Q.8. Find number of tuples in customer relation.
SQL> SELECT COUNT(*) AS tuple_no FROM customer;
TUPLE_NO
----------
12
Q.9. Calculate total loan amount given by bank.
SQL> SELECT SUM(amount) AS total_loan FROM loan;
TOTAL_LOAN
----------
2143800
Q.10. Delete all loans with loan amount between 1300 and 1500.
SQL> DELETE FROM loan WHERE amount BETWEEN 25000 AND 30000;
1 row deleted.
Q.11. Create sequence roll_seq and use in student table for roll_no column.
SQL> CREATE SEQUENCE roll_no START with 1 INCREMENT BY 1 MINVALUE 1 MAXVALUE 100
CYCLE;
Sequence created.
SQL> CREATE TABLE student(rollno number , name varchar(10));
Table created.
SQL> select * from student;
ROLLNO NAME
---------- ----------
1 Harshad
2 Nayan
3 Aviraj























Problem statement 4.
a) Create following Tables with suitable data and solve following query
cust_mstr(custno,fname,lname)
acc_fd_cust_dets(codeno,acc_fd_no)
fd_dets(fd_sr_no,amt)
List the customer holding fixed deposit of amount more than 5000
SQL> CREATE TABLE fd_dets(fd_sr_no number primary key ,amt number);
Table created.
SQL> select * from cust_mstr;
CUST_NO FNAME LNAME
---------- ---------- ----------
1 Harshad Karale
2 Aviraj Kale
3 Nayan Keote
SQL> select * from fd_dets;
FD_SR_NO AMT
---------- ----------
1 2000
2 6000
3 8000
4 10000
SQL> CREATE TABLE acc_fd_cust_dets(codeno number references cust_mstr(cust_no) on
delete cascade,acc_fd_no number references fd_dets(fd_sr_no) on delete cascade);
Table created.
SQL> select * from acc_fd_cust_dets;
CODENO ACC_FD_NO
---------- ----------
1 1
2 2
3 3
SQL> select * from cust_mstr where cust_no IN(SELECT codeno from acc_fd_cust_dets
where acc_fd_no IN(SELECT fd_sr_no FROM fd_dets where amt>5000));
CUST_NO FNAME LNAME
---------- ---------- ----------
2 Aviraj Kale
3 Nayan Keote
b) Create view on cust_mstr and acc_fd_cust_dets tables by selecting any one column
from each table perform insert update delete operations
1. Create a view selecting any one column from each table:
CREATE VIEW cust_acc_view AS SELECT c.cust_name, a.acc_no FROM cust_mstr c JOIN 
acc_fd_cust_dets a ON c.cust_no = a.cust_no;
2. Perform insert operation on the view:
INSERT INTO cust_acc_view (cust_name, acc_no) VALUES ('John Doe', 123456);
3. Perform update operation on the view:
UPDATE cust_acc_view SET acc_no = 654321 WHERE cust_name = 'John Doe';
4. Perform delete operation on the view:
DELETE FROM cust_acc_view WHERE cust_name = 'John Doe';
c) Create following Tables with suitable data and solve following query
emp_mstr(emp_no,f_name,l_name,m_name,dept)
cntc_dets(code_no,cntc_type,cntc_data)
List the employee details along with contact details using left outer join & right join
SQL> CREATE TABLE branch_mstr(name char(10),b_no number primary key);
Table created.
SQL> select * from branch_mstr;
NAME B_NO
---------- ----------
Computer 1
MECH 2
IT 3
Civil 4
SQL> CREATE TABLE emp_mstr(emp_no number NOT NULL,fname char(10),lname
char(10),mname char(10),dept char(10),desg char(10),branch_no number references
branch_mstr(b_no) on delete set null);
Table created.
SQL> select * from emp_mstr;
EMP_NO FNAME LNAME MNAME DEPT DESG BRANCH_NO
---------- ---------- ---------- ---------- ---------- ---------- ----------
1 Harshad Karale Sanjay Comp Student 1
SQL> select * from emp_mstr where branch_no IN(select b_no from branch_mstr where
name = 'Computer');
EMP_NO FNAME LNAME MNAME DEPT DESG BRANCH_NO
---------- ---------- ---------- ---------- ---------- ---------- ----------
1 Harshad Karale Sanjay Comp Student 1
4. Create following Tables emp_mstr(emp_no,f_name,l_name,m_name,dept)
cntc_dets(code_no,cntc_type,cntc_data) List the employee details along with contact
details using left outer join & right join
SQL> CREATE TABLE emp_mstr(emp_no number primary key,fname char(10),lname
char(10),mname char(10),dept char(10));
Table created.
SQL> select * from emp_mstr;
EMP_NO FNAME LNAME MNAME DEPT
---------- ---------- ---------- ---------- ----------
1 Harshad Karale Sanjay Comp
2 Aviraj Kale Popat IT
3 Nayan Keote Gajanan AIML
4 Ashirwad Katakamwar Rajeshwar Entc
5 Rushi Magadum Ranjit Comp
SQL> CREATE TABLE cntc_dets(codeno number references
emp_mstr(emp_no),cntc_type varchar(20),cntc_data varchar(20));
Table created.
SQL> select * from cntc_dets;
CODENO CNTC_TYPE CNTC_DATA
---------- -------------------- --------------------
1 Email harshad@gmail.com
2 Mob 9322918702
3 Email nayan@gmail.com
3 mob 1234567890
LEFT OUTER JOIN:
SQL> select * from emp_mstr LEFT OUTER JOIN cntc_dets ON
emp_mstr.emp_no = cntc_dets.codeno;
EMP_NO FNAME LNAME MNAME DEPT CODENO
---------- ---------- ---------- ---------- ---------- ----------
1 Harshad Karale Sanjay Comp 1
2 Aviraj Kale Popat IT 2
3 Nayan Keote Gajanan AIML 3
4 Ashirwad Katakamwar Rajeshwar Entc
5 Rushi Magadum Ranjit Comp
CNTC_TYPE CNTC_DATA
-------------------- --------------------
Email harshad@gmail.com
Mob 9322918702
Email nayan@gmail.com
RIGHT OUTER JOIN
SQL> select * from emp_mstr RIGHT OUTER JOIN cntc_dets ON
emp_mstr.emp_no = cntc_dets.codeno;
EMP_NO FNAME LNAME MNAME DEPT CODENO
---------- ---------- ---------- ---------- ---------- ----------
CNTC_TYPE CNTC_DATA
-------------------- --------------------
1 Harshad Karale Sanjay Comp 1
Email harshad@gmail.com
2 Aviraj Kale Popat IT 2
Mob 9322918702
3 Nayan Keote Gajanan AIML 3
Email nayan@gmail.com
3 Nayan Keote Gajanan AIML 3
mob 1234567890
5. Create following Tables cust_mstr(cust_no,fname,lname) add_dets(code_no,pincode) List
the customer who do not have bank branches in their vicinity.
SQL> CREATE TABLE cust_mstr(cust_no varchar(10) primary key ,fname char(10),lname
char(10));
Table created.
SQL> select * from cust_mstr;
CUST_NO FNAME LNAME
---------- ---------- ----------
C1 Harshad Karale
C2 Aviraj Kale
C3 Nayan Keote
SQL> select * from add_dets;
SQL> CREATE TABLE add_dets(codeno varchar(10),pincode number);
Table created.
CODENO PINCODE
---------- ----------
B1 410510
C1 410510
C2 410511
C3 410512
SQL> select * from cust_mstr where cust_no IN(select codeno from add_dets where
codeno like 'C%' AND pincode NOT IN(select pincode from add_dets where codeno like
'B%'));
CUST_NO FNAME LNAME
---------- ---------- ----------
C2 Aviraj Kale
C3 Nayan Keote




















Problem statement 5.
a) Consider following database schema and solve given queries
cust_mstr(cust_no,fname,lname)
add_dets(code_no,add1,add2,state,city,pincode)
1. Create above Tables with suitable data
2. Retrieve the address of customer Fname as 'xyz' and Lname as 'pqr'
3. Create View on add_dets table by selecting any two columns and perform insert update
delete operations
b)Create following Tables
cust_mstr(cust_no,fname,lname)
add_dets(code_no,pincode)
(Most of the queries are similar as follow)
List the customer who do not have bank branches in their vicinity.

a) SQL Queries:

Create Tables with Suitable Data:


CREATE TABLE cust_mstr (
    cust_no INT PRIMARY KEY,
    fname VARCHAR(50),
    lname VARCHAR(50)
);

CREATE TABLE add_dets (
    code_no INT PRIMARY KEY,
    add1 VARCHAR(100),
    add2 VARCHAR(100),
    state VARCHAR(50),
    city VARCHAR(50),
    pincode INT
);

-- Inserting data into cust_mstr
INSERT INTO cust_mstr (cust_no, fname, lname) VALUES
(1, 'John', 'Doe'),
(2, 'Jane', 'Smith');

-- Inserting data into add_dets
INSERT INTO add_dets (code_no, add1, add2, state, city, pincode) VALUES
(101, '123 Main St', 'Apt 101', 'California', 'Los Angeles', 90001),
(102, '456 Oak Ave', 'Suite 201', 'California', 'San Francisco', 94102);

2.Retrieve the Address of Customer Fname as 'xyz' and Lname as 'pqr':

SELECT add1, add2, state, city, pincode
FROM cust_mstr
JOIN add_dets ON cust_mstr.cust_no = add_dets.code_no
WHERE fname = 'John' AND lname = 'Doe';

3.Create View on add_dets Table and Perform Insert, Update, Delete Operations:

CREATE VIEW add_dets_view AS
SELECT add1, city
FROM add_dets;

-- Insert Operation
INSERT INTO add_dets_view (add1, city) VALUES ('789 Elm St', 'New York');

-- Update Operation
UPDATE add_dets_view SET city = 'Chicago' WHERE add1 = '123 Main St';

-- Delete Operation
DELETE FROM add_dets_view WHERE add1 = '456 Oak Ave';

b) Creating Tables:


CREATE TABLE cust_mstr (
    cust_no INT PRIMARY KEY,
    fname VARCHAR(50),
    lname VARCHAR(50)
);

CREATE TABLE add_dets (
    code_no INT PRIMARY KEY,
    pincode INT
);

-- Sample data for cust_mstr
INSERT INTO cust_mstr (cust_no, fname, lname) VALUES
(1, 'Alice', 'Johnson'),
(2, 'Bob', 'Smith');

-- Sample data for add_dets
INSERT INTO add_dets (code_no, pincode) VALUES
(101, 90001),
(102, 94102),
(103, 60601);

-- Query to list customers who do not have bank branches in their vicinity
SELECT cust_no, fname, lname
FROM cust_mstr
WHERE cust_no NOT IN (SELECT code_no FROM add_dets WHERE pincode IN (SELECT DISTINCT




























Problem statement 6.
Q 1.Consider table Stud(Roll, Att,Status)
Write a PL/SQL block for following requirement and handle the exceptions.
Roll no. of student will be entered by user. Attendance of roll no. entered by user will be 
checked in
Stud table. If attendance is less than 75% then display the message “Term not granted” 
and set the
status in stud table as “D”. Otherwise display message “Term granted” and set the status 
in stud
table as “ND”.
SQL> CREATE TABLE stud(roll_no NUMBER PRIMARY KEY , att NUMBER ,status char(5));
Table created.
SQL> select * from stud;
ROLL_NO ATT STATU
---------- ---------- -----
123 95 NULL
129 99 NULL
133 94 NULL
137 97 NULL
300 60 NULL
301 70 NULL
Declare
mroll number(10);
matt number(10);
Begin
mroll:=&mroll;
select att into matt from stud where roll_no = mroll;
if matt<75 then
dbms_output.put_line(mroll || 'is detained');
update stud set status='D' where roll_no = mroll;
else
dbms_output.put_line(mroll || 'is not detained');
update stud set status='ND' where roll_no = mroll;
end if;
Exception
when no_data_found then
dbms_output.put_line(mroll || 'Not found');
End;
/
SQL> select * from stud;
ROLL_NO ATT STATU
---------- ---------- -----
123 95 ND
129 99 ND
133 94 ND
137 97 ND
300 60 D
301 70 D
6 rows selected.
Q 2.The bank manager has decided to activate all those accounts which were previously 
marked as
inactive for performing no transaction in last 365 days. Write a PL/SQ block (using implicit 
cursor)
to update the status of account, display an approximate message based on the no. of rows 
affected
by the update. (Use of %FOUND, %NOTFOUND, %ROWCOUNT)
SELECT * FROM account;
ACC_NO NAME STATUS
---------- ---------- ----------
129 Harshad active
123 Avi inactive
122 Aadi inactive
137 Nayan active
4 rows selected.
BEGIN
UPDATE account SET status = 'active' WHERE status = 'inactive';
dbms_output.put_line(SQL%ROWCOUNT||' no of account updated');
END;
/
2 no of account updated
PL/SQL procedure successfully completed.
SELECT * FROM account;
ACC_NO NAME STATUS
---------- ---------- ----------
129 Harshad active
123 Avi active
122 Aadi active
137 Nayan active
4 rows selected.
BEGIN
UPDATE account SET status = 'active' WHERE status = 'inactive';
dbms_output.put_line(SQL%ROWCOUNT||' no of account updated');
END;
/
0 no of account updated

























Problem statement 7.
Q 1. Write an SQL code block these raise a user defined exception where business rule is 
voilated.
BR for client_master table specifies when the value of bal_due field is less than 0 handle 
the
exception.
Declare
input number(10);
client_id number;
bal_due Exception;
Begin
client_id :=& client_id;
input :=&input;
IF input < 0 THEN
raise bal_due;
ELSE
INSERT INTO client_master VALUES(client_id,input);
dbms_output.put_line('Inserted successfully');
END IF;
Exception
when bal_due then
dbms_output.put_line(input || 'Your balance is less then 0');
End;
Enter value for client_id: 3
old 6: client_id :=& client_id;
new 6: client_id :=3;
Enter value for input: -10
old 7: input :=&input;
new 7: input :=-10;
-10
Your balance is less then 0
Enter value for client_id: 2
old 6: client_id :=& client_id;
new 6: client_id :=2;
Enter value for input: 100
old 7: input :=&input;
new 7: input :=100;
Inserted successfully
Q 2. Organization has decided to increase the salary of employees by 10% of existing 
salary, who
are having salary less than average salary of organization, Whenever such salary updates 
takes
place, a record for the same is maintained in the increment_salary table.
EMP (E_no , Salary)
increment_salary(E_no , Salary)
SELECT * FROM salary;
EMP_NO SALARY
---------- ----------
129 11000
123 22000
137 30000
DECLARE
CURSOR salhigh IS SELECT emp_no,salary FROM salary WHERE salary < (SELECT
AVG(salary) FROM salary);
memp_no salary.emp_no%type;
msalary salary.salary%type;
BEGIN
OPEN salhigh;
IF salhigh%isopen THEN
LOOP
fetch salhigh into memp_no,msalary;
exit when salhigh%notfound;
if salhigh%found then
update salary set salary = (0.1*msalary+ msalary) WHERE emp_no = memp_no;
insert into increment_salary values(memp_no,0.1*msalary+ msalary);
end if;
end loop;
end if;
Close salhigh;
END;
/
PL/SQL procedure successfully completed.
SELECT * FROM salary;
EMP_NO SALARY
---------- ----------
129 12100
123 24200
137 33000
SELECT * FROM increment_salary;
EMP_NO INCREMENT_SALARY
---------- ----------------
121 12100
122 24200
129 33000



























Problem statement 8.
Q 1.Borrower(Roll_no, Name, DateofIssue, NameofBook, Status)
Fine(Roll_no,Date,Amt)
1. Accept roll_no& name of book from user.
2. Check the number of days (from date of issue), if days are between 15 to 30 then fine 
amount
will be Rs 5per day.
3. If no. of days>30, per day fine will be Rs 50 per day & for days less than 30, Rs. 5 per day.
After submitting the book, status will change from I to R
4. If condition of fine is true, then details will be stored into fine table.
5. Also handles the exception by named exception handler or user define exception 
handler.
CREATE PROCEDURE process_borrower_fine (
mroll_no IN NUMBER
)
IS
days INTEGER;
doi DATE;
dor DATE := SYSDATE;
mamt NUMBER;
BEGIN
SELECT dateofissue INTO doi FROM borrower WHERE roll_no = mroll_no;
days := dor - doi;
dbms_output.put_line(days);
UPDATE borrower SET status = 'r' WHERE roll_no = mroll_no;
IF (days > 30) THEN
mamt := (days - 30) * 50 + 75;
INSERT INTO fine VALUES (mroll_no, dor, mamt);
ELSIF (days > 15) THEN
mamt := (days - 15) * 5;
INSERT INTO fine VALUES (mroll_no, dor, mamt);
END IF;
END;
SQL> BEGIN
2 process_borrower_fine(&mroll_no);
3 END;
4 /
SQL> select * from fine;
ROLL_NO DATEOFRET AMT
---------- --------- ----------
3 16-FEB-24 40
4 16-FEB-24 150
2 16-FEB-24 5
3 16-FEB-24 40
4 rows selected.


























Problem statement 9.
Q 1. Write PL/SQL block using explicit cursor for following requirements:
College has decided to mark all those students detained (D) who are having attendance 
less than
75%.
Whenever such update takes place, a record for the same is maintained in the D_Stud 
table.
create table stud21(roll number(4), att number(4), status varchar(1));
create table d_stud(roll number(4), att number(4));
SELECT * FROM stud;
ROLL_NO ATT S
---------- ---------- -
129 90
137 74
123 50
DECLARE
CURSOR check_status IS SELECT roll_no,att FROM stud WHERE att < 75 ;
mroll_no stud.roll_no%type;
matt stud.att%type;
BEGIN
OPEN check_status;
IF check_status%isopen THEN
LOOP
FETCH check_status INTO mroll_no,matt;
exit WHEN check_status%notfound;
IF check_status%found THEN
UPDATE stud SET status = 'D' WHERE roll_no = mroll_no;
INSERT INTO d_stud VALUES(mroll_no,matt);
END IF;
END LOOP;
END IF;
CLOSE check_status;
END;
/
PL/SQL procedure successfully completed.
SELECT * FROM stud;
ROLL_NO ATT S
---------- ---------- -
129 90
137 74 D
123 50 D
SELECT * FROM d_stud;
ROLL_NO ATT
---------- ----------
137 74
123 50























Problem statement10.
Q 1.Consider table Stud(Roll, Att,Status)
Write a PL/SQL block for following requirement and handle the exceptions.
Roll no. of student will be entered by user. Attendance of roll no. entered by user will be 
checked in
Stud table. If attendance is less than 75% then display the message “Term not granted” 
and set the
status in stud table as “D”. Otherwise display message “Term granted” and set the status 
in stud
table as “ND”.
(Taken From ChatGPT)
DECLARE
 v_roll_number Stud.Roll%TYPE;
 v_attendance Stud.Att%TYPE;
 v_status Stud.Status%TYPE;
BEGIN
 -- Accepting roll number from user
 v_roll_number := &roll_number;
 -- Retrieving attendance and status for the entered roll number
 SELECT Att, Status
 INTO v_attendance, v_status
 FROM Stud
 WHERE Roll = v_roll_number;
 -- Checking attendance percentage and updating status accordingly
 IF v_attendance < 75 THEN
 DBMS_OUTPUT.PUT_LINE('Term not granted');
 UPDATE Stud
 SET Status = 'D'
 WHERE Roll = v_roll_number;
 ELSE
 DBMS_OUTPUT.PUT_LINE('Term granted');
 UPDATE Stud
 SET Status = 'ND'
 WHERE Roll = v_roll_number;
 END IF;
EXCEPTION
 WHEN NO_DATA_FOUND THEN
 DBMS_OUTPUT.PUT_LINE('Roll number not found');
 WHEN OTHERS THEN
 DBMS_OUTPUT.PUT_LINE('An error occurred: ' || SQLERRM);
END;
/
Q 2.Write a update, delete trigger on clientmstr table. The System should keep track of the 
records
that ARE BEING updated or deleted. The old value of updated or deleted records should be 
added
in audit_trade table. (separate implementation using both row and statement triggers)
CREATE OR REPLACE TRIGGER trade_record
AFTER INSERT OR DELETE
ON client
FOR EACH ROW
DECLARE
op VARCHAR(10);
BEGIN
IF updating THEN
op:='update';
END IF;
IF deleting THEN
op:='Delete';
END IF;
INSERT INTO trade VALUES(:old.c_id,:old.p_amt,op);
END;
/
Trigger created.
SELECT * FROM client;
C_ID P_AMT
---------- ----------
121 1500
122 1800
129 1500
124 1900
125 3000
SELECT * FROM trade;
no rows selected
CREATE OR REPLACE TRIGGER trade_record
AFTER UPDATE OR DELETE
ON client
FOR EACH ROW
DECLARE
op VARCHAR(10);
BEGIN
IF updating THEN
op:='update';
END IF;
IF deleting THEN
op:='Delete';
END IF;
INSERT INTO trade VALUES(:old.c_id,:old.p_amt,op);
END;
/
Trigger created.
SELECT * FROM client;
C_ID P_AMT
---------- ----------
121 1500
122 1800
129 1500
124 1900
125 3000
SELECT * FROM trade;
no rows selected
UPDATE client SET p_amt = 1000 WHERE p_amt=1500;
4 rows updated.
SELECT * FROM trade;
C_ID P_AMT STATUS
---------- ---------- ----------
121 1500 update
129 1500 update
CREATE OR REPLACE TRIGGER trade_record
AFTER UPDATE OR DELETE
ON client
DECLARE
op VARCHAR(10);
BEGIN
IF updating THEN
op:='update';
END IF;
IF deleting THEN
op:='Delete';
END IF;
INSERT INTO trade VALUES(:old.c_id,:old.p_amt,op);
END;
CREATE TABLE trade_status(status VARCHAR(10));
Table created.
CREATE OR REPLACE TRIGGER trade_record
AFTER UPDATE OR DELETE
ON client
DECLARE
op VARCHAR(10);
BEGIN
IF updating THEN
op:='update';
END IF;
IF deleting THEN
op:='Delete';
END IF;
INSERT INTO trade_status VALUES(op);
END;
/
Trigger created.
SELECT * FROM client;
C_ID P_AMT
---------- ----------
121 1000
122 1000
129 1000
124 1000
125 3000
UPDATE client SET p_amt = 1500 WHERE p_amt=1000;
4 rows updated.
SELECT * FROM trade_status;
STATUS
----------
Update
























Problem statement11.
Q 1. Write a stored function in PL/SQL for given requirement and use the same in PL/SQL 
block.
Account no. and branch name will be accepted from user. The same will be searched in 
table
acct_details. If status of account is active then display appropriate message and also store 
the
account details in active_acc_details table, otherwise display message on screen “account 
is
inactive”.
SQL> create table acc_details(acc_no NUMBER primary key , b_name char(10) , status 
char(2));
Table created.
SQL> SELECT * FROM acc_details;
ACC_NO B_NAME ST
---------- ---------- --
1 Nigdi A
2 Nigdi I
3 Nigdi A
4 Khed I
5 Khed I
CREATE OR REPLACE FUNCTION account_fun (
macc_no IN NUMBER,
b_name IN CHAR -- Removed size specification
) RETURN CHAR -- Removed size specification
IS
mst CHAR(2); -- It's okay to specify sizes for internal variables
BEGIN
SELECT status INTO mst FROM acc_details
WHERE acc_no = macc_no AND b_name = b_name; -- Use the parameter b_name
RETURN mst;
EXCEPTION
WHEN NO_DATA_FOUND THEN
RETURN NULL; -- Return NULL if no data is found
WHEN OTHERS THEN
RETURN NULL; -- General error handling
END;
Function created.
DECLARE
macc_no NUMBER(10);
mst CHAR(2);
b_name CHAR(10); -- Example value for b_name
BEGIN
macc_no := &macc_no;
b_name := '&b_name';
mst := account_fun(macc_no, b_name); -- Corrected function name and added b_name
IF mst = 'A' THEN
DBMS_OUTPUT.PUT_LINE('Account is active'); -- Corrected quotes and added missing 
parenthesis
INSERT INTO active_acc_details VALUES(macc_no,b_name,mst);
ELSE
DBMS_OUTPUT.PUT_LINE('Account is Inactive'); -- Corrected quotes and added missing 
parenthesis
END IF;
END;
SQL> select * from active_acc_details;
ACC_NO B_NAME ST
---------- -------------------- --
1 1 A
1 1 A
3 Nigdi A
Enter value for macc_no: 2
old 6: macc_no := &macc_no;
new 6: macc_no := 2;
Enter value for b_name: Nigdi
old 7: b_name := '&b_name';
new 7: b_name := 'Nigdi';
Account is Inactive

























Problem statement12.
Q 1. Write an SQL code block these raise a user defined exception where business rule is 
voilated.
BR for client_master table specifies when the value of bal_due field is less than 0 handle 
the
exception.
Declare
input number(10);
client_id number;
bal_due Exception;
Begin
client_id :=& client_id;
input :=&input;
IF input < 0 THEN
raise bal_due;
ELSE
INSERT INTO client_master VALUES(client_id,input);
dbms_output.put_line('Inserted successfully');
END IF;
Exception
when bal_due then
dbms_output.put_line(input || 'Your balance is less then 0');
End;
Enter value for client_id: 3
old 6: client_id :=& client_id;
new 6: client_id :=3;
Enter value for input: -10
old 7: input :=&input;
new 7: input :=-10;
-10
Your balance is less then 0
Enter value for client_id: 2
old 6: client_id :=& client_id;
new 6: client_id :=2;
Enter value for input: 100
old 7: input :=&input;
new 7: input :=100;
Inserted successfully
Q 2.Write a before trigger for Insert, update event considering following requirement:
Emp(e_no, e_name, salary)
I) Trigger action should be initiated when salary is tried to be inserted is less than Rs. 
50,000/-
II) Trigger action should be initiated when salary is tried to be updated for value less than 
Rs.
50,000/-
Action should be rejection of update or Insert operation by displaying appropriate error 
message.
Also the new values expected to be inserted will be stored in new table.
Tracking(e_no, salary).
SELECT * FROM employee;
no rows selected
CREATE OR REPLACE TRIGGER emp_sal_record
2 BEFORE UPDATE OR INSERT
3 ON employee
4 FOR EACH ROW
5 DECLARE
6 sal NUMBER:=:new.salary;
7 BEGIN
8 IF sal < 50000 THEN
9 IF updating THEN
10 raise_application_error(-20003,'This update opration violet comapany rule / record
not inserted');
11 END IF;
12 IF inserting THEN
13 raise_application_error(-20003,'This insert opration violet comapany rule / record
not inserted');
14 END IF;
15 ELSE
16 DBMS_OUTPUT.PUT_LINE('Record created successfully');
17 INSERT INTO emp_sal VALUES(:new.e_no,:new.salary);
18 END IF;
19 END;
20 /
Trigger created.
INSERT INTO employee VALUES(129,'Aviraj',100000);
Record created successfully
1 row created.
INSERT INTO employee VALUES(124,'Ankit',1000);
INSERT INTO employee VALUES(124,'Ankit',1000)
UPDATE employee SET salary = 1000 WHERE e_no =129;




























Problem statement13.
Q 1. . Write a PL/SQL stored Procedure for following requirements and call the procedure 
in appropriate
PL/SQL block.
Borrower(Rollin, Name, DateofIssue, NameofBook, Status)
Fine(Roll_no,Date,Amt)
Accept roll_no& name of book from user.
1. Check the number of days (from date of issue), if days are between 15 to 30 then fine 
amount
will be Rs 5per day.
2. If no. of days>30, per day fine will be Rs 50 per day & for days less than 30, Rs. 5 per day.
3. After submitting the book, status will change from I to R.
4. If condition of fine is true, then details will be stored into fine table.
CREATE PROCEDURE process_borrower_fine (
mroll_no IN NUMBER
)
IS
days INTEGER;
doi DATE;
dor DATE := SYSDATE;
mamt NUMBER;
BEGIN
SELECT dateofissue INTO doi FROM borrower WHERE roll_no = mroll_no;
days := dor - doi;
dbms_output.put_line(days);
UPDATE borrower SET status = 'r' WHERE roll_no = mroll_no;
IF (days > 30) THEN
mamt := (days - 30) * 50 + 75;
INSERT INTO fine VALUES (mroll_no, dor, mamt);
ELSIF (days > 15) THEN
mamt := (days - 15) * 5;
INSERT INTO fine VALUES (mroll_no, dor, mamt);
END IF;
END;
SQL> BEGIN
2 process_borrower_fine(&mroll_no);
3 END;
4 /
SQL> select * from fine;
ROLL_NO DATEOFRET AMT
---------- --------- ----------
3 16-FEB-24 40
4 16-FEB-24 150
2 16-FEB-24 5
3 16-FEB-24 40
4 rows selected.
























Problem statement14.
Q 1. Write a Stored Procedure namely proc_Grade for the categorization of student. If 
marks
scored by students in examination is <=1500 and marks>=990 then student will be placed 
in
distinction category if marks scored are between 989 and900 category is first class, if 
marks 899
and 825 category is Higher Second Class.
Write a PL/SQL block for using procedure created with above requirement.
Stud_Marks(name, total_marks)
Result(Roll,Name, Class)
SQL> select * from stud_marks;
ROLL_NO MARKS
---------- ----------
1 1270
2 870
3 970
CREATE OR REPLACE PROCEDURE proc_Grade(
p_name IN VARCHAR2,
p_marks IN NUMBER,
p_roll IN NUMBER)
IS
v_class VARCHAR2(100);
BEGIN
IF p_marks <= 1500 AND p_marks >= 990 THEN
v_class := 'Dist';
ELSIF p_marks < 990 AND p_marks >= 900 THEN
v_class := 'First';
ELSIF p_marks < 900 AND p_marks >= 825 THEN
v_class := 'Higher';
ELSE
v_class := 'Other';
END IF;
INSERT INTO Result VALUES (p_roll, p_name, v_class);
END;
DECLARE
v_name VARCHAR2(100);
v_total_marks NUMBER;
v_roll NUMBER;
BEGIN
v_roll := &v_roll;
v_name := '&v_name';
select marks INTO v_total_marks FROM stud_marks where roll_no = v_roll;
proc_Grade(v_name, v_total_marks, v_roll);
END;
SQL> select * from Result;
ROLL_NO NAME CLASS
---------- -------------------- ----------
1 Harshad Dist
2 Nayan Higher
3 Aviraj First

























Problem statement15.
Create Database PCCOE
Create following Collections
Teachers(Tname,dno,dname,experience,salary,date_of_joining )
Students(Sname,roll_no,class)
Q1. Find the information about all teachers
Q2. Find the information about all teachers of computer department
Q3. Find the information about all teachers of computer,IT,ande&TC department
Q4. Find the information about all teachers of computer,IT,and E&TC department having 
salary
greater than or equl to 10000/-
Q5. Find the student information having roll_no = 2 or Sname=xyz
Q6. Update the experience of teacher-praveen to 10years, if the entry is not available in 
database
consider the entry as new entry.
Q7. Update the deparment of all the teachers working in IT deprtment to COMP
Q8. Find the teachers name and their experience from teachers collection
Q9. Using Save() method insert one entry in department collection
Q10. Using Save() method change the dept of teacher praveen to IT
Q11. Delete all the doccuments from teachers collection having IT dept.
Q12. Display with pretty() method, the first 3 doccuments in teachers collection in 
ascending order.

1.Create Database and Tables:

CREATE DATABASE PCCOE;

CREATE TABLE Teachers (
    Tname VARCHAR(50),
    dno INT,
    dname VARCHAR(50),
    experience INT,
    salary DECIMAL(10, 2),
    date_of_joining DATE
);

CREATE TABLE Students (
    Sname VARCHAR(50),
    roll_no INT,
    class VARCHAR(50)
);

2.Query to Find Information about all Teachers:

SELECT * FROM Teachers;

3.Query to Find Information about Teachers of Computer Department:

SELECT * FROM Teachers WHERE dname = 'Computer';

4.Query to Find Information about Teachers of Computer, IT, and E&TC Department with Salary >= 10000:

SELECT * FROM Teachers 
WHERE dname IN ('Computer', 'IT', 'E&TC') 
AND salary >= 10000;

5.Query to Find Student Information with Roll_no = 2 or Sname = 'xyz':

SELECT * FROM Students WHERE roll_no = 2 OR Sname = 'xyz';

6.Query to Update Experience of Teacher "Praveen" to 10 years:

UPDATE Teachers 
SET experience = 10 
WHERE Tname = 'Praveen';

7.Query to Update Department of all Teachers working in IT Department to "COMP":

UPDATE Teachers 
SET dname = 'COMP' 
WHERE dname = 'IT';

8.Query to Find Teachers' Names and their Experience:

SELECT Tname, experience FROM Teachers;

9.Using Save() method to Insert One Entry in Department Collection:

-- SQL databases typically don't use a Save() method like MongoDB, but you can use INSERT INTO to insert data into the department table.
INSERT INTO department (dept_name) VALUES ('XYZ');

10.Using Save() method to Change Department of Teacher "Praveen" to "IT":

-- Assuming the Teachers table has a unique identifier like teacher_id
UPDATE Teachers
SET dname = 'IT'
WHERE Tname = 'Praveen';

11.Delete all the documents from Teachers collection having IT department:

DELETE FROM Teachers WHERE dname = 'IT';

12.Display with pretty() method, the first 3 documents in Teachers collection in ascending order:

-- SQL databases typically don't have a pretty() method, but you can retrieve the first 3 documents and display them.
SELECT * FROM Teachers ORDER BY Tname LIMIT 3;






























Problem statements16
Consider the relational database
Supplier(Sid,Sname,address)
Parts(Pid, Pname, Color)
Catalog(sid,pid,cost)
Q. Find name of all parts whose color is green.
SELECT Pname
FROM Parts
WHERE Color = 'green';
Q. Find names of suppliers who supply some red parts.
SELECT DISTINCT Sname
FROM Supplier
WHERE Sid IN (
 SELECT Sid
 FROM Catalog
 WHERE pid IN (
 SELECT Pid
 FROM Parts
 WHERE Color = 'red'
 )
);
Q. Find names of all parts whose cost is more than Rs25.
SELECT Pname
FROM Parts
WHERE Pid IN (
 SELECT pid
 FROM Catalog
 WHERE cost > 25
);
Consider the relational database
Person(pname,street city)
Company(cname,city)
Manages(pname,mname)
Q. Find the street and city of all employees who work for “Idea”, live in Pune and earn 
more than 3000.
SELECT p.street, p.city
FROM Person p
JOIN Manages m ON p.pname = m.pname
JOIN Company c ON m.mname = c.cname
WHERE c.cname = 'Idea' AND p.city = 'Pune' AND p.pname IN (
 SELECT pname
 FROM Manages
 GROUP BY pname
 HAVING MIN(salary) > 3000
);
Consider the relational database
Student(Rollno,name,address)
Subject(sub_code,sub_name)
Marks(Rollno,sub_code, marks)
Q. Find out average marks of each student along with the name of student.
SELECT s.name, AVG(m.marks) AS average_marks FROM Student s JOIN Marks m ON s.Rollno
= m.Rollno GROUP BY s.Rollno, s.name;
Q. Find how many students have failed in the subject “DBMS”
SELECT COUNT(*) AS num_failed_students FROM Marks WHERE sub_code =SELECT
sub_code FROM Subject WHERE sub_name = 'DBMS') AND marks < 40;





























Problem statements17
Write Pl/SQL code block that will accept account number from user , check if the users 
balance is less than
the minimum balance , only deduct Rs.100/- from the balance .
CREATE TABLE Account (Acc_no NUMBER PRIMARY KEY, branch_name VARCHAR2(50),
balance NUMBER);
INSERT INTO Account (Acc_no, branch_name, balance)VALUES (1, 'Branch1', 1500);
INSERT INTO Account (Acc_no, branch_name, balance)VALUES (2, 'Branch2', 2000);
INSERT INTO Account (Acc_no, branch_name, balance)VALUES (3, 'Branch3', 100);
DECLARE
 v_acc_no NUMBER;
 v_balance NUMBER;
 v_min_balance NUMBER := 1000; -- Minimum balance required
BEGIN
 -- Accepting account number from user
 v_acc_no := &acc_no;
 -- Retrieving balance for the entered account number
 SELECT balance INTO v_balance
 FROM Account
 WHERE Acc_no = v_acc_no;
 -- Checking if balance is less than minimum balance
 IF v_balance < v_min_balance THEN
 UPDATE Account
 SET balance = balance - 100
 WHERE Acc_no = v_acc_no;
 DBMS_OUTPUT.PUT_LINE('Deducted Rs.100 from the balance.');
 ELSE
 DBMS_OUTPUT.PUT_LINE('Balance is above minimum balance.');
 END IF;
 COMMIT; -- Committing the transaction
EXCEPTION
 WHEN NO_DATA_FOUND THEN
 DBMS_OUTPUT.PUT_LINE('Account number not found.');
 WHEN OTHERS THEN
 DBMS_OUTPUT.PUT_LINE('An error occurred: ' || SQLERRM);
 ROLLBACK; -- Rolling back the transaction in case of error
END;
/




















Problem statements18
Write Pl/SQL code block for inverting number 1234 to 4321.
DECLARE
 v_number NUMBER := 1234; -- Number to invert
 v_inverted_number NUMBER := 0;
 v_remainder NUMBER;
BEGIN
 WHILE v_number > 0 LOOP
 v_remainder := MOD(v_number, 10);
 v_inverted_number := v_inverted_number * 10 + v_remainder;
 v_number := (v_number - v_remainder) / 10;
 END LOOP;
 DBMS_OUTPUT.PUT_LINE('Inverted Number: ' || v_inverted_number);
END;
/























Problem statements19
The bank manager has decided to mark all those accounts as inactive (I) on which there are no
transactions performed in last 365 days. Whenever any such update takes place a record for the
same is maintained in the INACT_MASTER_TABLE comprising of the account number, the
opening date and type of account. Write PL/SQL code block to do the same(cursor for loop)

Here's how you can write a PL/SQL code block using a cursor for loop to mark inactive accounts and maintain records in the INACT_MASTER_TABLE:


-- Create the INACT_MASTER_TABLE if it doesn't exist
CREATE TABLE INACT_MASTER_TABLE (
    account_number NUMBER,
    opening_date DATE,
    account_type VARCHAR2(50)
);

-- PL/SQL code block to mark inactive accounts and maintain records
DECLARE
    CURSOR inactive_accounts_cur IS
        SELECT account_number, opening_date, account_type
        FROM accounts
        WHERE last_transaction_date < SYSDATE - 365;
BEGIN
    FOR inactive_account_rec IN inactive_accounts_cur LOOP
        -- Mark account as inactive (assuming there's an 'active_status' column in the 'accounts' table)
        UPDATE accounts
        SET active_status = 'I'
        WHERE account_number = inactive_account_rec.account_number;

        -- Insert record into INACT_MASTER_TABLE
        INSERT INTO INACT_MASTER_TABLE (account_number, opening_date, account_type)
        VALUES (inactive_account_rec.account_number, inactive_account_rec.opening_date, inactive_account_rec.account_type);
    END LOOP;
END;
/
























Problem statements20
Write PL/SQL code block that will merge the data available in the newly created table
NEW_BRANCHES with the data available in the table BRANCH_MASTER. If the data in the first
table already exists in the second table then data should be skipped.(parameterized cursor)

Here's a PL/SQL code block that uses a parameterized cursor to merge data from the NEW_BRANCHES table into the BRANCH_MASTER table, skipping data that already exists:


-- Assume BRANCH_MASTER and NEW_BRANCHES tables exist with similar structure

-- PL/SQL code block to merge data
DECLARE
    v_branch_id BRANCH_MASTER.branch_id%TYPE;
    v_branch_name BRANCH_MASTER.branch_name%TYPE;
    v_branch_location BRANCH_MASTER.branch_location%TYPE;

    CURSOR new_branches_cur IS
        SELECT branch_id, branch_name, branch_location
        FROM NEW_BRANCHES;

BEGIN
    FOR new_branch_rec IN new_branches_cur LOOP
        -- Check if the branch_id from NEW_BRANCHES already exists in BRANCH_MASTER
        SELECT branch_id
        INTO v_branch_id
        FROM BRANCH_MASTER
        WHERE branch_id = new_branch_rec.branch_id;

        -- If branch_id exists, skip to next record
        IF v_branch_id IS NULL THEN
            -- Insert data from NEW_BRANCHES into BRANCH_MASTER
            INSERT INTO BRANCH_MASTER (branch_id, branch_name, branch_location)
            VALUES (new_branch_rec.branch_id, new_branch_rec.branch_name, new_branch_rec.branch_location);
        END IF;
    END LOOP;
END;
/



















Problem statements21
Write PL/SQL code block such that depending upon user supplied account number, the 
customer to
whom account belongs , the introducer of that account are inserted into
ACCOUNT_MASTER_INFO table .If the user enters an account number that is not in the
ACCOUNT_MASTER table, then the PL/SQL block must display appropriate error
message(Exception Handling)
DECLARE
 v_acc_no NUMBER := &account_number; -- User-supplied account number
 v_cust_name VARCHAR2(100);
 v_introducer VARCHAR2(100);
BEGIN
 SELECT cust_name, introducer
 INTO v_cust_name, v_introducer
 FROM ACCOUNT_MASTER
 WHERE acc_no = v_acc_no;
 INSERT INTO ACCOUNT_MASTER_INFO (acc_no, cust_name, introducer)
 VALUES (v_acc_no, v_cust_name, v_introducer);
 DBMS_OUTPUT.PUT_LINE('Record inserted successfully.');
EXCEPTION
 WHEN NO_DATA_FOUND THEN
 DBMS_OUTPUT.PUT_LINE('Account number not found in ACCOUNT_MASTER table.');
 WHEN OTHERS THEN
 DBMS_OUTPUT.PUT_LINE('An error occurred: ' || SQLERRM);
END;
/






















Problem statements22
A stored function is created to perform the ACCOUNT_NO check operation 
.F_checkAccNO() is
the name of function which accept a variable ACCOUNT_NO and returns the value to host
environment The value changes from 0(if ACCOUNT_NO does not exist) to 1(if 
ACCOUNT_NO
exist) depending on the records retrieved.
CREATE OR REPLACE FUNCTION F_checkAccNO (p_account_no IN NUMBER)
RETURN NUMBER
IS
 v_count NUMBER;
BEGIN
 -- Check if the account number exists in the table
 SELECT COUNT(*)
 INTO v_count
 FROM ACCOUNT_MASTER
 WHERE acc_no = p_account_no;
 -- Return 1 if account number exists, otherwise return 0
 RETURN CASE WHEN v_count > 0 THEN 1 ELSE 0 END;
END;
/
DECLARE
 v_result NUMBER;
BEGIN
 v_result := F_checkAccNO(123456789); -- Replace 123456789 with the account number 
you want to check
 IF v_result = 1 THEN
 DBMS_OUTPUT.PUT_LINE('Account number exists.');
 ELSE
 DBMS_OUTPUT.PUT_LINE('Account number does not exist.');
 END IF;
END;
/




















Problem statements23
create a row level trigger for the CUSTOMERS table that would fire for INSERT or UPDATE 
or DELETE
operations performed on the CUSTOMERS table. This trigger will display the salary 
difference between the old
values and new values
CREATE OR REPLACE TRIGGER customers_salary_trigger
BEFORE INSERT OR UPDATE OR DELETE ON customers
FOR EACH ROW
DECLARE
 v_old_salary NUMBER;
 v_new_salary NUMBER := :NEW.salary;
BEGIN
 IF INSERTING OR UPDATING THEN
 v_old_salary := :OLD.salary;
 DBMS_OUTPUT.PUT_LINE('Salary difference: ' || (v_new_salary - v_old_salary));
 ELSIF DELETING THEN
 DBMS_OUTPUT.PUT_LINE('Salary deleted: ' || :OLD.salary);
 END IF;
END;
/

















Problem statements24
Write PL/SQL block to update the Customer table and increase the salary of each customer by 500
and use the SQL%ROWCOUNTattribute to determine the number of rows affected.

Here's a PL/SQL block to update the Customer table and increase the salary of each customer by 500, using the SQL%ROWCOUNT attribute to determine the number of rows affected:


DECLARE
    v_num_rows_affected NUMBER;

BEGIN
    -- Increase the salary of each customer by 500
    UPDATE Customer
    SET salary = salary + 500;

    -- Get the number of rows affected by the update
    v_num_rows_affected := SQL%ROWCOUNT;

    -- Output the number of rows affected
    DBMS_OUTPUT.PUT_LINE('Number of rows updated: ' || v_num_rows_affected);
END;
/














Assignment No.2


Problem Statement :
Create below tables with appropriate constraints like primary key, foreign key, check
constrains, not null etc.

Account(Acc_no, branch_name,balance)
branch(branch_name,branch_city,assets)
customer(cust_name,cust_street,cust_city)
Depositor(cust_name,acc_no)
Loan(loan_no,branch_name,amount)
Borrower(cust_name,loan_no)
Output:
SQL> create table branch_b123(branch_name varchar(15) Primary Key,assets number,branch_city varchar(10));

Table created.
SQL> Insert into branch_b123 values('Nigdi',10000000,'Pune');
1 row created.
SQL> Insert into branch_b123 values('Akurdi',10000000,'Pune');
1 row created.
SQL> Insert into branch_b123 values('Haveli',10000000,'Pune');
1 row created.
SQL> Insert into branch_b123 values('Pimpri',10000000,'Pune');
1 row created.

SQL> SELECT * FROM branch_b123;

BRANCH_NAME         ASSETS BRANCH_CITY
--------------- ---------- ----------
Nigdi             10000000 Pune
Akurdi            10000000 Pune
Haveli            10000000 Pune
Pimpri            10000000 Pune


SQL> create table account_b123(account_number varchar(10) Primary Key,branch_name varchar(15) References branch_b123(branch_name),balance number);

Table created.
SQL> Insert into account_b123 values('A000','Nigdi',1000);
1 row created.
SQL> Insert into account_b123 values('A001','Nigdi',1000);
1 row created.
SQL> Insert into account_b123 values('A002','Akurdi',2000);
1 row created.
SQL> Insert into account_b123 values('A003','Haveli',2000);
1 row created.
SQL> Insert into account_b123 values('A004','Akurdi',2000);
1 row created.
SQL> Insert into account_b123 values('A005','Haveli',4000);
1 row created.
SQL> Insert into account_b123 values('A006','Haveli',5000);
1 row created.
SQL> Insert into account_b123 values('A007','Pimpri',5000);
1 row created.
SQL> Insert into account_b123 values('A008','Akurdi',15000);
1 row created.
SQL> Insert into account_b123 values('A009','Akurdi',15000);
1 row created.
SQL> Insert into account_b123 values('A010','Pimpri',6000);
1 row created.

SQL> SELECT * FROM account_b123;

ACCOUNT_NU BRANCH_NAME        BALANCE
---------- --------------- ----------
A000       Nigdi                 1000
A001       Nigdi                 1000
A002       Akurdi                2000
A003       Haveli                2000
A004       Akurdi                2000
A005       Haveli                4000
A006       Haveli                5000
A007       Pimpri                5000
A008       Akurdi               15000
A009       Akurdi               15000
A010       Pimpri                6000

11 rows selected.

SQL> create table customer_b123(customer_name varchar(15) Primary Key,customer_street varchar(15),custmer_city varchar(10));

Table created.

SQL> Insert into customer_b123 values('Aviraj','Akurdi chowk','Pune');
1 row created.
SQL> Insert into customer_b123 values('Atharva','Akurdi chowk','Pune');
1 row created.
SQL> Insert into customer_b123 values('Harshad','Ganesh talav','Pune');
1 row created.
SQL> Insert into customer_b123 values('Nayan','Ganesh talav','Pune');
1 row created.
SQL> Insert into customer_b123 values('Aaditesh','Ganesh talav','Pune');
1 row created.
SQL> Insert into customer_b123 values('Aashirwad','Akurdi Station','Pune');
1 row created.
SQL> Insert into customer_b123 values('Aishwarya','Akurdi Station','Pune');
1 row created.
SQL> Insert into customer_b123 values('Aditya','Akurdi Station','Pune');
1 row created.
SQL> SELECT * FROM customer_b123;

CUSTOMER_NAME   CUSTOMER_STREET CUSTMER_CI
--------------- --------------- ----------
Aviraj          Akurdi chowk    Pune
Atharva         Akurdi chowk    Pune
Harshad         Ganesh talav    Pune
Nayan           Ganesh talav    Pune
Aaditesh        Ganesh talav    Pune
Aashirwad       Akurdi Station  Pune
Aishwarya       Akurdi Station  Pune
Aditya          Akurdi Station  Pune

8 rows selected.
SQL> Insert into loan_b123 values('L01','Pimpri',6000);
1 row created.

SQL> Insert into loan_b123 values('L02','Pimpri',1000);
1 row created.

SQL> Insert into loan_b123 values('L03','Akurdi',10000);
1 row created.
SQL> Insert into loan_b123 values('L04','Akurdi',12000);
1 row created.

SQL> SELECT * FROM loan_b123;

LOAN_NUMBE BRANCH_NAME         AMOUNT
---------- --------------- ----------
L01        Pimpri                6000
L02        Pimpri                1000
L03        Akurdi               10000
L04        Akurdi               12000

SQL> create table depositer_b123(customer_name varchar(15) References customer_b123(customer_name) on delete cascade,account_number varchar(10) References account_b123(account_number) on delete set null );

Table created.
SQL> Insert into depositer_b123 values('Harshad','A000');
1 row created.
SQL> Insert into depositer_b123 values('Aviraj','A001');
1 row created.
SQL> Insert into depositer_b123 values('Nayan','A004');
1 row created.
SQL> Insert into depositer_b123 values('Aaditesh','A003');
1 row created.
SQL> SELECT * FROM depositer_b123;

CUSTOMER_NAME   ACCOUNT_NU
--------------- ----------
Harshad         A000
Aviraj          A001
Nayan           A004
Aaditesh        A003

SQL> create table borrower_b123(customer_name varchar(15) References customer_b123(customer_name) on delete cascade,account_number varchar(10) References loan_b123(loan_number) on delete set null );
Table created.
SQL> Insert into borrower_b123 values('Nayan','L04')
1 row created.
SQL> Insert into borrower_b123 values('Harshad','L04');
1 row created.
SQL> Insert into borrower_b123 values('Aditya','L03');
1 row created.
SQL> Insert into borrower_b123 values('Aviraj','L01');
1 row created.
SQL> SELECT * FROM borrower_b123;

CUSTOMER_NAME   ACCOUNT_NU
--------------- ----------
Nayan           L04
Harshad         L04
Aditya          L03
Aviraj          L01


Query :
Q1. Find the names of all branches in loan relation.
SQL> SELECT distinct branch_name from loan_b123;

BRANCH_NAME
---------------
Akurdi
Pimpri

Q2. Find all loan numbers for loans made at Akurdi Branch with loan amount > 12000.
SQL> SELECT loan_number from loan_b123 where branch_name='Akurdi' AND amount>=12000;

LOAN_NUMBE
----------
L04

SQL>
Q3. Find all customers who have a loan from bank. Find their names,loan_no and loan amount.
SQL> SELECT borrower_b123.customer_name,loan_b123.loan_number,loan_b123.amount From loan_b123 Inner join borrower_b123 ON loan_b123.loan_number=borrower_b123.account_number;

CUSTOMER_NAME   LOAN_NUMBE     AMOUNT
--------------- ---------- ----------
Nayan           L04             12000
Harshad         L04             12000
Aditya          L03             10000
Aviraj          L01              6000

Q4. List all customers in alphabetical order who have loan from Akurdi branch.
SQL> SELECT * FROM customer_b123 WHERE customer_name IN (SELECT customer_name FROM borrower_b123 WHERE loan_number IN (SELECT loan_number FROM loan_b123 WHERE branch_name ='Akurdi')) ORDER BY customer_name;


CUSTOMER_NAME   CUSTOMER_STREET CUSTMER_CI
--------------- --------------- ----------
Aditya          Akurdi Station  Pune
Harshad         Ganesh talav    Pune
Nayan           Ganesh talav    Pune

Q5. Find all customers who have an account or loan or both at bank.
SQL> SELECT * FROM customer_b123 WHERE customer_name IN (SELECT customer_name FROM borrower_b123 UNION SELECT customer_name FROM depositer_b123);

CUSTOMER_NAME   CUSTOMER_STREET CUSTMER_CI
--------------- --------------- ----------
Aviraj          Akurdi chowk    Pune
Harshad         Ganesh talav    Pune
Nayan           Ganesh talav    Pune
Aaditesh        Ganesh talav    Pune
Aditya          Akurdi Station  Pune

Q6. Find all customers who have both account and loan at bank.
SELECT * FROM customer_b123 WHERE customer_name IN (SELECT customer_name FROM borrower_b123 INTERSECT SELECT customer_name FROM depositer_b123);




CUSTOMER_NAME   CUSTOMER_STREET CUSTMER_CI
--------------- --------------- ----------
Aviraj          Akurdi chowk    Pune
Harshad         Ganesh talav    Pune
Nayan           Ganesh talav    Pune

Q7. Find all customer who have account but no loan at the bank.
 SELECT * FROM customer_b123 WHERE customer_name IN (SELECT customer_name FROM borrower_b123 MINUS SELECT customer_name FROM depositer_b123);

CUSTOMER_NAME   CUSTOMER_STREET CUSTMER_CI
--------------- --------------- ----------
Aditya          Akurdi Station  Pune
Q8. Find average account balance at Akurdi branch.
SQL> SELECT AVG(balance) AS avrage_account_balance FROM account_b123 WHERE branch_name = 'Akurdi';

AVRAGE_ACCOUNT_BALANCE
----------------------
        8500

Q9. Find the average account balance at each branch
SQL> SELECT branch_name,ROUND(AVG(balance)) AS avrage_account_balance FROM account_b123 GROUP BY branch_name;

BRANCH_NAME     AVRAGE_ACCOUNT_BALANCE
--------------- ----------------------
Nigdi                             1000
Akurdi                            8500
Haveli                            3667
Pimpri                            5500

Q10. Find no. of depositors at each branch.
SELECT branch_name,COUNT(*) FROM account_b123 GROUP BY branch_name;

BRANCH_NAME       COUNT(*)
--------------- ----------
Nigdi                    2
Akurdi                   4
Haveli                   3
Pimpri                   2
Q11. Find the branches where average account balance > 12000.
SQL> SELECT branch_name,AVG(balance) AS AVRAGE_BAL FROM account_b123 GROUP BY branch_name HAVING AVG(balance) >1500;
BRANCH_NAME     AVRAGE_BAL
--------------- ----------
Akurdi                8500
Haveli          3666.66667
Pimpri                5500
Q12. Find number of tuples in customer relation.
SQL> SELECT count(*) FROM customer_b123 ;

  COUNT(*)
----------
         8
Q13. Calculate total loan amount given by bank.
SQL> SELECT SUM(AMOUNT) FROM loan_b123  ;

SUM(AMOUNT)
-----------
      29000
Q14. Delete all loans with loan amount between 1300 and 1500.
LOAN_NUMBE BRANCH_NAME         AMOUNT
---------- --------------- ----------
L01        Pimpri                6000
L02        Pimpri                1000
L03        Akurdi               10000
L04        Akurdi               12000

SQL> SELECT SUM(AMOUNT) FROM loan_b123  ;
SUM(AMOUNT)
-----------
      29000

SQL> DELETE FROM loan_b123 WHERE AMOUNT BETWEEN 1300 AND 1500;
0 rows deleted.

SQL> DELETE FROM loan_b123 WHERE AMOUNT BETWEEN 900 AND 1500;
1 row deleted.

SQL> SELECT * FROM loan_b123  ;

LOAN_NUMBE BRANCH_NAME         AMOUNT
---------- --------------- ----------
L01        Pimpri                6000
L03        Akurdi               10000
L04        Akurdi               12000

SQL>
Q15. Delete all tuples at every branch located in Nigdi.
 	1 row deleted.
Q.16. Create synonym for customer table as cust.

SQL> CREATE SYNONYM cust_b123 FOR customer_b123;
Synonym created.

SQL> SELECT * FROM cust_b123;

CUSTOMER_NAME   CUSTOMER_STREET CUSTMER_CI
--------------- --------------- ----------
Aviraj          Akurdi chowk    Pune
Atharva         Akurdi chowk    Pune
Harshad         Ganesh talav    Pune
Nayan           Ganesh talav    Pune
Aaditesh        Ganesh talav    Pune
Aashirwad       Akurdi Station  Pune
Aishwarya       Akurdi Station  Pune
Aditya          Akurdi Station  Pune

8 rows selected.
Q.17. Create sequence roll_seq and use in student table for roll_no column
SQL> CREATE SEQUENCE roll_no_b123 START WITH 1 INCREMENT BY 1 MINVALUE 1 MAXVALUE 100 CYCLE;

Sequence created.
SQL> CREATE TABLE student_b123(roll_no NUMBER,name VARCHAR(10));
Table created.

SQL> INSERT INTO student_b123 VALUES(roll_no_b123.nextval,'KALYANI');

1 row created.
SQL> INSERT INTO student_b123 VALUES(roll_no_b123.nextval,'”AVIRAJ');
1 row created.
SQL> INSERT INTO student_b123 VALUES(roll_no_b123.nextval,'SAPANA');
1 row created.
SQL> INSERT INTO student_b123 VALUES(roll_no_b123.nextval,'ATHARVA');
1 row created.
SQL> SELECT * FROM student_b123;

   ROLL_NO NAME
---------- ----------
         1 KALYANI
         2 AVIRAJ
         3 SAPANA
         4 ATHARVA




















Assignment No.3

Output
1. Create following Tables
cust_mstr(cust_no,fname,lname)
add_dets(code_no,add1,add2,state,city,pincode)

SQL> CREATE TABLE address_b123(code_no varchar(10),
  2  add1 varchar(10),add2 varchar(20),state varchar(10),city varchar(10),pin varchar(10),
  3  PRIMARY KEY(code_no));
Table created.
SQL> SELECT * FROM address_b123;

CODE_NO    ADD1       ADD2                 STATE      CITY       PIN
---------- ---------- -------------------- ---------- ---------- ----------
A123       Gurdwara   Akurdi               Maha       Pune       422605
A124       Gurdwara   Nigdi                Maha       Pune       422605
B124       Chowk      Pimpri               Maha       Pune       422605




SQL> CREATE TABLE customer_master_b123(cust_no number PRIMARY KEY,fname varchar(20) not null,lname varchar(20),code_no varchar(10) REFERENCES address_b123(code_no));

Table created.

SQL> SELECT * FROM customer_master_b123;

   CUST_NO FNAME                LNAME                CODE_NO
---------- -------------------- -------------------- ----------
         1 Aviraj               Kale                 A123
         2 Harshad             Karale               A124
         4 Nayan               Keote                B124
         3 Riya                 Jadhav               A124


Retrieve the address of customer Fname as 'Harshad' and Lname as 'Karale'

SQL> SELECT * FROM address_b123 WHERE code_no IN (SELECT code_no FROM customer_master_b123 WHERE fname='Harshad' AND lname='Karale');

CODE_NO    ADD1       ADD2                 STATE      CITY       PIN
---------- ---------- -------------------- ---------- ---------- ----------
A124       Gurdwara   Nigdi                Maha       Pune       422605
2.Create following Tables
cust_mstr(custno,fname,lname)
acc_fd_cust_dets(codeno,acc_fd_no)
fd_dets(fd_sr_no,amt)


SQL> CREATE TABLE customer_master_b123(cust_no number PRIMARY KEY,fname varchar(20) not null,lname varchar(20));

Table created.
SQL> SELECT * FROM customer_master_b123;

   CUST_NO FNAME                LNAME
---------- -------------------- --------------------
       123 Aviraj               Kale
       129 Harshad              Karale
       122 Aadi                 Kadu

SQL> CREATE TABLE fixed_deposite_b123(fd_sr_no number PRIMARY KEY,amount NUMBER ,CHECK (amount>0));

Table created.



SQL> SELECT * FROM fixed_deposite_b123;

  FD_SR_NO     AMOUNT
---------- ----------
         1      20000
         2       1000
         3       6000
         4       2000


SQL> CREATE TABLE customer_fixed_deposite(cust_no NUMBER REFERENCES customer_master_b123(cust_no) on delete cascade,fd_sr_no NUMBER REFERENCES fixed_deposite_b123(fd_sr_no) on delete cascade);

Table created.
List the customer holding fixed deposit of amount more than 5000;
SQL> SELECT * FROM customer_master_b123 WHERE cust_no IN (SELECT cust_no FROM customer_fixed_deposite WHERE fd_sr_no IN (SELECT fd_sr_no FROM fixed_deposite_b123 WHERE amount>5000 ));

   CUST_NO FNAME                LNAME
---------- -------------------- --------------------
       123 Aviraj               Kale
       129 Harshad              Karale
       122 Aadi                 Kadu

SQL> SELECT fname,lname FROM customer_master_b123 ,customer_fixed_deposite,fixed_deposite_b123 WHERE customer_master_b123.cust_no = customer_fixed_deposite.cust_no AND
  2  customer_fixed_deposite.fd_sr_no=fixed_deposite_b123.fd_sr_no AND amount>19000;

FNAME                LNAME
-------------------- --------------------
Aviraj               Kale
Aadi                 Kadu

3. Create following Tables
emp_mstr(e_mpno,f_name,l_name,m_name,dept,desg,branch_no)
branch_mstr(name,b_no)

SQL> SELECT * FROM branch_mstr_b123;
NAME                            B_NO
------------------------- ----------
Computer Eng.                    100
IT                               101
Civil                            102
EnTC                             104

List the employee details along with branch names to which they belong.
SQL> SELECT emp_no,fname,mname,lname,dept,desg,name FROM emp_mstr_b123,branch_mstr_b123 WHERE branch_no = b_no;

EMP_N FNAME           MNAME           LNAME      DEPT  DESG   NAME
E1    Atharva         Eknath          Shinde          SY    Stud
Computer Eng.
E3    Sapana          Madhkar         Shinde          SY    Stud
IT
E2    Atharva         Eknath          Shinde          SY    Stud
IT
E4    Aish            Ulhas           Kadhane         SY    Stud
EnTC















4. Create following Tables
emp_mstr(emp_no,f_name,l_name,m_name,dept)
cntc_dets(code_no,cntc_type,cntc_data)

SQL> CREATE TABLE emp_mstr_b123(emp_no varchar(10) PRIMARY KEY,fname varchar(10),lname varchar(10),mname varchar(10),dept varchar(15));

Table created.
SQL> CREATE TABLE cntc_dets_b123(code_no varchar(10) REFERENCES emp_mstr_b123(emp_no),cntc_type varchar(10),cntc_data varchar(10));

Table created.

List the employee details along with contact details using left outer join & right join

SQL> SELECT * FROM emp_mstr_b123 LEFT OUTER JOIN cntc_dets_b123 ON emp_no = code_no;

EMP_NO     FNAME      LNAME      MNAME      DEPT            CODE_NO
---------- ---------- ---------- ---------- --------------- ----------
CNTC_TYPE  CNTC_DATA
---------- ----------
E4         Aish       Kadhane    Ulhas      IT              E4
Personal   90100122
E4         Aish       Kadhane    Ulhas      IT              E4
Office     90100122
E2         Atharva    Shinde     Eknath     Comp            E2
Personal   90100144
E3         Nayan      Keote      Eknath     Comp            E3
Personal   80100144
E5         Harshad    Karale     Sanjay     Comp

SQL> SELECT * FROM emp_mstr_b123 RIGHT OUTER JOIN cntc_dets_b123 ON emp_no = code_no;

EMP_NO     FNAME      LNAME      MNAME      DEPT            CODE_NO
---------- ---------- ---------- ---------- --------------- ----------
CNTC_TYPE  CNTC_DATA
---------- ----------
E4         Aish       Kadhane    Ulhas      IT              E4
Office     90100122
E4         Aish       Kadhane    Ulhas      IT              E4
Personal   90100122
E2         Atharva    Shinde     Eknath     Comp            E2
Personal   90100144
E3         Nayan      Keote      Eknath     Comp            E3
Personal   80100144
5. Create following Tables
cust_mstr(cust_no,fname,lname)
add_dets(code_no,pincode)

SQL> CREATE TABLE cust_mstr_b123(cust_no varchar(10) PRIMARY KEY,f_name varchar(10),l_name varchar(10));
Table created.
SQL> SELECT * FROM add_dets_b123;
CODE_NO       PINCODE
---------- ----------
C1               1225
C2               1225
B1               1225
C4               1226
B2               1226
C3               1221

6 rows selected.
List the customer who do not have bank branches in their vicinity.

SQL> SELECT * FROM cust_mstr_b123 WHERE cust_no IN (SELECT code_no FROM add_dets_b123 WHERE code_no LIKE 'C%'AND pincode NOT IN(SELECT pincode FROM add_dets_b123 WHERE code_no LIKE 'B%'));

CUST_NO    F_NAME     L_NAME
---------- ---------- ----------
C3         Atharva    Shinde

6. 
a) Create View on borrower table by selecting any two columns and perform insert update delete operations

SQL> CREATE TABLE borrower_b123(emp_no NUMBER PRIMARY KEY , name VARCHAR(10) ,amt NUMBER);
Table created.
SQL> SELECT * FROM borrower_b123;
    EMP_NO NAME        AMT
    -------------------           ----------
         1 Harshad         10000
         2 Aviraj          20000
         3 Nayan           30000
SQL> SELECT * FROM b_view_b123;
    EMP_NO NAME         AMP
        --------------------  ----------
         1 Harshad         10000
         2 Aviraj          20000
         3 Nayan           30000
SQL> INSERT INTO b_view_b123 values(4,'Aadi',40000);
1 row created.
SQL> SELECT * from b_view_b123;

    EMP_NO NAME        AMP
    --------------------       ----------
         1 Harshad         10000
         2 Aviraj          20000
         3 Nayan           30000
         4 Aadi        40000
SQL> UPDATE b_view_b123 SET amt = 50000 WHERE emp_no = 1;
1 row updated.
SQL> SELECT * FROM b_view_b123;
	
    EMP_NO NAME              AMT
---------- ---------- ----------
         1 Harshad         50000
         2 Aviraj          20000
         3 Nayan           30000
         4 Ashirwad        40000
SQL> DELETE FROM b_view_b123 WHERE emp_no = 4;
1 row deleted.
SQL> SELECT * FROM b_view_b123;
    EMP_NO NAME              AMT
---------- ---------- ----------
         1 Harshad         50000
         2 Aviraj          20000
         3 Nayan           30000

b) Create view on borrower and depositor table by selecting any one column from each table perform insert update delete operations
SQL> SELECT * FROM borrower_b123;
      B_ID NAME              AMT
---------- ---------- ----------
       100 Harshad       1000000
       101 Nayan             100
       103 Aadi           100000

SQL>  ALTER TABLE borrower_b123 MODIFY b_id number PRIMARY KEY;
Table altered.
SQL> CREATE TABLE depositer_b123(d_id number PRIMARY KEY,name varchar(10),amt number);
Table created.
SQL> CREATE VIEW b_d_b123 AS SELECT b_id,d_id FROM borrower_b123,depositer_b123 WHERE b_id = d_id;
View created.
SQL> SELECT * FROM b_d_b123;

      B_ID       D_ID
---------- ----------
       100        100
       101        101
       103        103

SQL> INSERT INTO b_d_b123 VALUES(104,104);
INSERT INTO b_d_b123 VALUES(104,104)
*
ERROR at line 1:
ORA-01776: cannot modify more than one base table through a join view
SQL> UPDATE b_d_b123 SET b_id=102 WHERE d_id=100;
1 row updated.
SQL> DELETE FROM b_d_b123 WHERE d_id=100;
0 rows deleted.
SQL> SELECT * FROM b_d_b123;
      B_ID       D_ID
      ---------- ----------
       101        101
       103        103
--------------------------------------------END----------------------------------------------------------






















Assignment No.4

Output
--Program For Hello World
SQL> Begin
  2  dbms_output.put_line('Hello SQL , I am here');
  3  End;
  4  /
Hello SQL , I am here
PL/SQL procedure successfully completed.

--Program for addition of two numbers
SQL> Declare
  2  a number(10);
  3  b number(10);
  4  Begin
  5  a:=&a;
  6  b:=&b;
  7  dbms_output.put_line(a+b||'is sum');
  8  End;
  9  /
Enter value for a: 10
old   5: a:=&a;
new   5: a:=10;
Enter value for b: 15
old   6: b:=&b;
new   6: b:=15;
25is sum
PL/SQL procedure successfully completed.

1. Consider table Stud(Roll, Att,Status)
Write a PL/SQL block for following requirement and handle the exceptions. Roll no. of student will be entered by user. Attendance of roll no. entered by user will be checked in Stud table. If attendance is less than 75% then display the message “Term not granted” and set the status in stud table as “D”. Otherwise display message “Term granted” and set the status in stud table as “ND”.

SQL> SELECT * FROM stud_b123;

   ROLL_NO        ATT STATU
       ---------- ---------- -----
       101         60
       102         70
       103         80
       104         90

SQL> Declare
  2  mroll number(10);
  3  matt number(10);
  4  Begin
  5  mroll:= &mroll;
  6  select att into matt from stud_b123 where roll_no = mroll;
  7  if matt<75 then
  8  dbms_output.put_line('Term not granted');
  9  update stud_b123 set status='D'where roll_no =mroll;
 10  else
 11  dbms_output.put_line('Term granted');
 12  update stud_b123 set status='ND'where roll_no =mroll;
 13  end if;
 14  Exception
 15  when no_data_found then
 16  dbms_output.put_line(mroll||'Not found');
 17  End;
 18  /
Enter value for mroll: 101
old   5: mroll:= &mroll;
new   5: mroll:= 101;
Term not granted
PL/SQL procedure successfully completed.



2. Write a PL/SQL block for following requirement using user defined exception handling.The account_master table records the current balance for an account, which is updated whenever, any deposits or withdrawals takes place. If the withdrawal attempted is more than the current balance held in the account. The user defined exception is raised, displaying an appropriate message. Write a PL/SQL block for above requirement using user defined exception handling.
SQL> DECLARE
  2      buffer_amount NUMBER(10);
  3      i_account_number NUMBER(10);
  4      for_deposite_1_else_0 NUMBER;
  5      i_amount NUMBER(10);
  6      insufficent_bal EXCEPTION;
  7  BEGIN
  8      i_account_number:= &i_account_number;
  9      for_deposite_1_else_0:=&for_deposite_1_else_0;
 10      i_amount:= &i_amount;
 11      SELECT amt INTO buffer_amount FROM account_master_b123 WHERE acc_no = i_account_number;
 12      IF for_deposite_1_else_0 = 1 THEN
 13          dbms_output.put_line('The deposition successful');
 14          UPDATE account_master_b123 SET amt =  i_amount + buffer_amount WHERE acc_no = i_account_number;
 15      ELSE
 16          IF buffer_amount < i_amount THEN
 17              RAISE insufficent_bal;
 18          END IF;
 19              dbms_output.put_line('The withdrawn successful');
 20              UPDATE account_master_b123 SET amt =  buffer_amount - i_amount  WHERE acc_no = i_account_number;
 21      END IF;
 22  EXCEPTION
 23      WHEN insufficent_bal THEN
 24      dbms_output.put_line('Insufficent Balance');
 25  END;
 26  /
Enter value for i_account_number: 101
old   8:     i_account_number:= &i_account_number;
new   8:     i_account_number:= 101;
Enter value for for_deposite_1_else_0: 1
old   9:     for_deposite_1_else_0:=&for_deposite_1_else_0;
new   9:     for_deposite_1_else_0:=1;
Enter value for i_amount: 100
old  10:     i_amount:= &i_amount;
new  10:     i_amount:= 100;
The deposition successful
PL/SQL procedure successfully completed.





SQL> SELECT * FROM account_master_b123;

    ACC_NO        AMT
---------- ----------
       101       9500
       102       2000
       103       4000
       105        500
       106         50
SQL> DECLARE
  2      buffer_amount NUMBER(10);
  3      i_account_number NUMBER(10);
  4      for_deposite_1_else_0 NUMBER;
  5      i_amount NUMBER(10);
  6      insufficent_bal EXCEPTION;
  7  BEGIN
  8      i_account_number:= &i_account_number;
  9      for_deposite_1_else_0:=&for_deposite_1_else_0;
 10      i_amount:= &i_amount;
 11      SELECT amt INTO buffer_amount FROM account_master_b123 WHERE acc_no = i_account_number;
 12      IF for_deposite_1_else_0 = 1 THEN
 13          dbms_output.put_line('The deposition successful');
 14          UPDATE account_master_b123 SET amt =  i_amount + buffer_amount WHERE acc_no = i_account_number;
 15      ELSE
 16          IF buffer_amount < i_amount THEN
 17              RAISE insufficent_bal;
 18          END IF;
 19              dbms_output.put_line('The withdrawn successful');
 20              UPDATE account_master_b123 SET amt =  buffer_amount - i_amount  WHERE acc_no = i_account_number;
 21      END IF;
 22  EXCEPTION
 23      WHEN insufficent_bal THEN
 24      dbms_output.put_line('Insufficent Balance');
 25  END;
 26  /
Enter value for i_account_number: 102
old   8:     i_account_number:= &i_account_number;
new   8:     i_account_number:= 102;
Enter value for for_deposite_1_else_0: 0
old   9:     for_deposite_1_else_0:=&for_deposite_1_else_0;
new   9:     for_deposite_1_else_0:=0;
Enter value for i_amount: 5000
old  10:     i_amount:= &i_amount;
new  10:     i_amount:= 5000;
Insufficent Balance
PL/SQL procedure successfully completed
3. Write an SQL code block these raise a user defined exception where business rule is voilated. BR for client_master table specifies when the value of bal_due field is less than 0 handle the exception.
SQL> SELECT * FROM account_master_b123;
    ACC_NO        AMT
---------- ----------
       101       1000
       102       1000
       103       1000
       104       2000
SQL> DECLARE
  2      i_account_number NUMBER(10);
  3      i_amount NUMBER(10);
  4      greater_zero_bal EXCEPTION;
  5  BEGIN
  6      i_account_number:= &i_account_number;
  7      i_amount :=&i_amount;
  8      IF i_amount < 1 THEN
  9         RAISE greater_zero_bal;
 10      END IF;
 11      INSERT INTO account_master_b123 VALUES (i_account_number,i_amount);
 12      dbms_output.put_line('Amount innserted successfully');
 13  EXCEPTION
 14      WHEN greater_zero_bal THEN
 15      dbms_output.put_line('You cannot insert balance less than 0');
 16      WHEN DUP_VAL_ON_INDEX THEN
 17          DBMS_OUTPUT.PUT_LINE('Account already exist');
 18  END;
 19  /
Enter value for i_account_number: 105
old   6:     i_account_number:= &i_account_number;
new   6:     i_account_number:= 105;
Enter value for i_amount: 2000
old   7:     i_amount :=&i_amount;
new   7:     i_amount :=2000;
Amount innserted successfully
PL/SQL procedure successfully completed.
SQL>
Enter value for i_account_number: 101
old   6:     i_account_number:= &i_account_number;
new   6:     i_account_number:= 101;
Enter value for i_amount: 100
old   7:     i_amount :=&i_amount;
new   7:     i_amount :=100;
Account already exist
PL/SQL procedure successfully completed.
SQL>


4. 
1. Borrower(Roll_no, Name, DateofIssue, NameofBook, Status)
2. Fine(Roll_no,Date,Amt)
•	Accept roll_no & name of book from user.
•	Check the number of days (from date of issue), if days are between 15 to 30 then fine amount will be Rs 5per day.
•	If no. of days>30, per day fine will be Rs 50 per day & for days less than 30, Rs. 5 per day.
•	After submitting the book, status will change from I to R.
•	 If condition of fine is true, then details will be stored into fine table.
Also handles the exception by named exception handler or user define exception handler.

SQL> SELECT * FROM borrower_b123;
   ROLL_NO NAME       DATE_OF_I NAME_OF_BOOK    ST
---------- ---------- --------- --------------- --
       101 Avi        01-FEB-24 Fire            R
       102 Avi        05-FEB-24 Fire            I
       103 Nayan      01-JAN-24 Fire            I
SQL> DECLARE
  2      fine INTEGER;
  3      mroll_no NUMBER;
  4      mdate_of_issue DATE;
  5  BEGIN
  6      mroll_no:= &mroll_no;
  7      UPDATE borrower_b123 SET status =  'R'  WHERE roll_no = mroll_no;
  8      SELECT date_of_issue INTO mdate_of_issue FROM borrower_b123 WHERE roll_no = mroll_no;
  9      IF SYSDATE - mdate_of_issue  > 30 THEN
 10          fine := ((SYSDATE - mdate_of_issue) -30) * 15 + 75;
 11          INSERT INTO fine_b123 VALUES (mroll_no,SYSDATE,fine);
 12          dbms_output.put_line('You get fine');
 13      ELSIF SYSDATE - mdate_of_issue  > 15 THEN
 14          fine := ((SYSDATE - mdate_of_issue) -15) * 5;
 15          INSERT INTO fine_b123 VALUES (mroll_no,SYSDATE,fine);
 16          dbms_output.put_line(SYSDATE - mdate_of_issue);
 17          dbms_output.put_line('You get fine');
 18      ELSE
 19          dbms_output.put_line('Book return successful');
 20      END IF;
 21  END;
 22  /
Enter value for mroll_no: 103
old   6:     mroll_no:= &mroll_no;
new   6:     mroll_no:= 103;
You get fine
PL/SQL procedure successfully completed.
SQL> SELECT * FROM fine_b123;


   ROLL_NO DATE_OF_R     AMOUNT
---------- --------- ----------
       103 16-FEB-24        325
DECLARE
  2      fine NUMBER;
  3      mroll_no NUMBER;
  4      mbook_name VARCHAR(15);
  5      mdate_of_issue DATE;
  6  BEGIN
  7      mroll_no:= &mroll_no;
  8      mbook_name :='&mbook_name';
  9      UPDATE borrower_b123 SET status =  'R'  WHERE roll_no = mroll_no;
 10      SELECT date_of_issue INTO mdate_of_issue FROM borrower_b123 WHERE roll_no = mroll_no AND name_of_book = mbook_name;
 11       IF SYSDATE - mdate_of_issue  > 30 THEN
 12          fine := ((SYSDATE - mdate_of_issue) -30) * 15 + 75;
 13          INSERT INTO fine_b123 VALUES (mroll_no,SYSDATE,fine);
 14          dbms_output.put_line('You get fine');
 15      ELSIF SYSDATE - mdate_of_issue  > 15 THEN
 16          fine := ((SYSDATE - mdate_of_issue) -15) * 5;
 17          INSERT INTO fine_b123 VALUES (mroll_no,SYSDATE,fine);
 18          dbms_output.put_line(SYSDATE - mdate_of_issue);
 19          dbms_output.put_line('You get fine');
 20      ELSE
 21          dbms_output.put_line('Book return successful');
 22      END IF;
 23  END;
 24  /
Enter value for mroll_no: 102
old   7:     mroll_no:= &mroll_no;
new   7:     mroll_no:= 102;
Enter value for mbook_name: Fire
old   8:     mbook_name :='&mbook_name';
new   8:     mbook_name :='Fire';
Book return successful
PL/SQL procedure successfully completed.
SQL>






















Assignment No.5

Output
1. Write a PL/SQL stored Procedure for following requirements and call the procedure in appropriate
PL/SQL block.
1. Borrower(Rollin, Name, DateofIssue, NameofBook, Status)
2. Fine(Roll_no,Date,Amt)
•	Accept roll_no &name of book from user.
•	Check the number of days (from date of issue), if days are between 15 to 30 then fine  amount will be Rs 5per day . 
•	If no. of days>30, per day fine will be Rs 50 per day & for days less than 30, Rs. 5 per day.
•	After submitting the book, status will change from I to R.
•	If condition of fine is true, then details will be stored into fine table.

   ROLL_NO NAME       DATE_OF_I NAME_OF_BOOK    ST
---------- ---------- --------- --------------- --
       101 Avi        01-FEB-24 Fire            	I
       102 Avi        05-FEB-24 Fire            I
       103 Nayan      01-JAN-24 Fire            I


SQL> CREATE OR REPLACE PROCEDURE calc_fine(mroll_no NUMBER) IS
  2      mdate_of_issue DATE;
  3      fine NUMBER;
  4  BEGIN
  5      UPDATE borrower_b123 SET status =  'R'  WHERE roll_no = mroll_no;
  6      SELECT date_of_issue INTO mdate_of_issue FROM borrower_b123 WHERE roll_no = mroll_no;
  7      IF SYSDATE - mdate_of_issue  > 30 THEN
  8          INSERT INTO fine_b123 VALUES (mroll_no,SYSDATE,(((SYSDATE - mdate_of_issue) -30) * 15 )+ 75);
  9          dbms_output.put_line('You get fine');
 10      ELSIF SYSDATE - mdate_of_issue  > 15 THEN
 11          fine := ((SYSDATE - mdate_of_issue) -15) * 5;
 12          INSERT INTO fine_b123 VALUES (mroll_no,SYSDATE,fine);
 13          dbms_output.put_line('You get fine');
 14      ELSE
 15          dbms_output.put_line('Book return successful');
 16      END IF;
 17  END calc_fine;
 18  /

Procedure created.



SQL> DECLARE
  2      mroll_no NUMBER;
  3  BEGIN
  4     mroll_no:= &mroll_no;
  5     calc_fine(mroll_no);
  6  END;
  7  /
Enter value for mroll_no: 101
old   4:    mroll_no:= &mroll_no;
new   4:    mroll_no:= 101;
PL/SQL procedure successfully completed.
SQL> SELECT * FROM borrower_b123;

   ROLL_NO NAME       DATE_OF_I NAME_OF_BOOK    ST
---------- ---------- --------- --------------- --
       101 Avi        01-FEB-24 Fire            R
       102 Avi        05-FEB-24 Fire            I
       103 Nayan      01-JAN-24 Fire            I






SQL> CREATE OR REPLACE PROCEDURE calc_fine(mroll_no NUMBER) IS
  2      mdate_of_issue DATE;
  3      fine INTEGER;
  4  BEGIN
  5      UPDATE borrower_b123 SET status =  'R'  WHERE roll_no = mroll_no;
  6      SELECT date_of_issue INTO mdate_of_issue FROM borrower_b123 WHERE roll_no = mroll_no;
  7      IF SYSDATE - mdate_of_issue  > 30 THEN
  8          INSERT INTO fine_b123 VALUES (mroll_no,SYSDATE,(((SYSDATE - mdate_of_issue) -30) * 15 )+ 75);
  9          dbms_output.put_line('You get fine');
 10      ELSIF SYSDATE - mdate_of_issue  > 15 THEN
 11          fine := ((SYSDATE - mdate_of_issue) -15) * 5;
 12          INSERT INTO fine_b123 VALUES (mroll_no,SYSDATE,fine);
 13          dbms_output.put_line('You get fine');
 14      ELSE
 15          dbms_output.put_line('Book return successful');
 16      END IF;
 17  END calc_fine;
 18  /
Procedure created.

SQL> DECLARE
  2      mroll_no NUMBER;
  3  BEGIN
  4     mroll_no:= &mroll_no;
  5     calc_fine(mroll_no);
  6  END;
  7
  8
  9  /
Enter value for mroll_no: 102
old   4:    mroll_no:= &mroll_no;
new   4:    mroll_no:= 102;
You get fine
PL/SQL procedure successfully completed.
SQL> SELECT * FROM borrower_b123;
   ROLL_NO NAME       DATE_OF_I NAME_OF_BOOK    ST
---------- ---------- --------- --------------- --
       101 Avi        01-FEB-24 Fire            R
       102 Avi        05-FEB-24 Fire            R
       103 Nayan      01-JAN-24 Fire            I
SQL> SELECT * FROM fine_b123;
   ROLL_NO DATE_OF_R     AMOUNT
---------- --------- ----------
       103 16-FEB-24        325
       101 21-FEB-24 27.3692708
       102 21-FEB-24          7
SQL> DECLARE
  2      mroll_no NUMBER;
  3  BEGIN
  4     mroll_no:= &mroll_no;
  5     calc_fine(mroll_no);
  6  END;
  7  /
Enter value for mroll_no: 103
old   4:    mroll_no:= &mroll_no;
new   4:    mroll_no:= 103;
You get fine
PL/SQL procedure successfully completed.
SQL> SELECT * FROM borrower_b123;
   ROLL_NO NAME       DATE_OF_I NAME_OF_BOOK    ST
---------- ---------- --------- --------------- --
       101 Avi        01-FEB-24 Fire            R
       102 Avi        05-FEB-24 Fire            R
       103 Nayan      01-JAN-24 Fire            R
SQL> SELECT * FROM fine_b123;
   ROLL_NO DATE_OF_R     AMOUNT
---------- --------- ----------
       103 16-FEB-24        325
       101 21-FEB-24     	27
       102 21-FEB-24          7
       103 21-FEB-24 		397

2. Write a stored function in PL/SQL for given requirement and use the same in PL/SQL block. Account no. and branch name will be accepted from user. The same will be searched in table acct_details. If status of account is active then display appropriate message and also store the account details in active_acc_details table, otherwise display message on screen “account is inactive”.
SQL> SELECT * FROM account_b123;
    ACC_NO BRANCH_NAME     STATUS
---------- --------------- ----------
       101 Nigadi          active
       102 Nigadi          not_active
       103 Akurdi          active

SQL> CREATE OR REPLACE FUNCTION check_status(macc_no NUMBER,mbranch_name VARCHAR) RETURN VARCHAR IS
  2      mstatus VARCHAR(10);
  3  BEGIN
  4      SELECT status INTO mstatus FROM account_b123 WHERE acc_no = macc_no;
  5      IF mstatus = 'not_active' THEN
  6          RETURN mstatus;
  7      ELSE
  8          INSERT INTO active_account_b123 VALUES (macc_no,mbranch_name);
  9          RETURN mstatus;
 10      END IF;
 11  END check_status;
 12  /
Function created.
SQL> DECLARE
  2      macc_no NUMBER;
  3      mbranch_name VARCHAR(15);
  4      mstatus VARCHAR(10);
  5  BEGIN
  6     macc_no:= &macc_no;
  7     mbranch_name:= '&mbranch_name';
  8     mstatus := check_status(macc_no,mbranch_name);
  9     IF mstatus = 'active' THEN
 10          dbms_output.put_line('Your account is Active');
 11     ELSE
 12         dbms_output.put_line('Your account is Not-Active');
 13     END IF;
 14  END;
 15  /
Enter value for macc_no: 101
old   6:    macc_no:= &macc_no;
new   6:    macc_no:= 101;
Enter value for mbranch_name: Nigadi
old   7:    mbranch_name:= '&mbranch_name';
new   7:    mbranch_name:= 'Nigadi';
Your account is Active
PL/SQL procedure successfully completed.
SQL> DECLARE
  2      macc_no NUMBER;
  3      mbranch_name VARCHAR(15);
  4      mstatus VARCHAR(10);
  5  BEGIN
  6     macc_no:= &macc_no;
  7     mbranch_name:= '&mbranch_name';
  8     mstatus := check_status(macc_no,mbranch_name);
  9     IF mstatus = 'active' THEN
 10          dbms_output.put_line('Your account is Active');
 11     ELSE
 12         dbms_output.put_line('Your account is Not-Active');
 13     END IF;
 14  END;
 15  /
Enter value for macc_no: 102
old   6:    macc_no:= &macc_no;
new   6:    macc_no:= 102;
Enter value for mbranch_name: Nigadi
old   7:    mbranch_name:= '&mbranch_name';
new   7:    mbranch_name:= 'Nigadi';
Your account is Not-Active
PL/SQL procedure successfully completed.

3. Write a Stored Procedure namely proc_Grade for the categorization of student. If marks scored by students in examination is <=1500 and marks>=990 then student will be placed in distinction category if marks scored are between 989 and900 category is first class, if marks 899 and 825 category is Higher Second Class .Write a PL/SQL block for using procedure created with above requirement.
Stud_Marks(name, total_marks)
Result(Roll,Name, Class)
SQL> CREATE TABLE student_b123(
  2      roll_no NUMBER,
  3      name VARCHAR(15),
  4      total_marks NUMBER,
  5      PRIMARY KEY(roll_no)
  6  );
Table created.
SQL> CREATE TABLE result_b123(
  2      roll_no NUMBER,
  3      name VARCHAR(15),
  4      class VARCHAR(20)
  5  );
Table created.

SQL> CREATE OR REPLACE PROCEDURE proc_grade(mroll_no NUMBER) IS
  2      mname VARCHAR(15);
  3      mtotal_marks NUMBER;
  4  BEGIN
  5      SELECT total_marks INTO mtotal_marks FROM student_b123 WHERE roll_no = mroll_no;
  6      SELECT name INTO mname FROM student_b123 WHERE roll_no = mroll_no;
  7      IF mtotal_marks <= 1500 AND mtotal_marks >= 990 THEN
  8          INSERT INTO result_b123 VALUES (mroll_no,mname,'Distinction');
  9          dbms_output.put_line('Student get Distinction');
 10      ELSIF mtotal_marks <= 989 AND mtotal_marks >= 900 THEN
 11          INSERT INTO result_b123 VALUES (mroll_no,mname,'First_class');
 12          dbms_output.put_line('Student get First Class');
 13      ELSIF  mtotal_marks <= 899 AND mtotal_marks >= 825 THEN
 14          INSERT INTO result_b123 VALUES (mroll_no,mname,'Second_class');
 15          dbms_output.put_line('Student get Second Class');
 16      ELSE
 17          INSERT INTO result_b123 VALUES (mroll_no,mname,'Fail');
 18           dbms_output.put_line('Student get Failed');
 19      END IF;
 20  END proc_grade;
 21  /
Procedure created.
SQL> DECLARE
  2      mroll_no NUMBER;
  3  BEGIN
  4     mroll_no:= &mroll_no;
  5     proc_grade(mroll_no);
  6  END;
  7  /
Enter value for mroll_no: 2
old   4:    mroll_no:= &mroll_no;
new   4:    mroll_no:= 2;
Student get First Class
PL/SQL procedure successfully completed.
SQL> DECLARE
  2      mroll_no NUMBER;
  3  BEGIN
  4     mroll_no:= &mroll_no;
  5     proc_grade(mroll_no);
  6  END;
  7  /
Enter value for mroll_no: 1
old   4:    mroll_no:= &mroll_no;
new   4:    mroll_no:= 1;
Student get Distinction
PL/SQL procedure successfully completed.
SQL> SELECT * FROM result_b123;
   ROLL_NO NAME            CLASS
---------- --------------- --------------------
         2 MASH            First_class
         1 AISH            Distinction






















Assignment No.6

Output
Implicit Cursor
1. The bank manager has decided to activate all those accounts which were previously marked as inactive for performing no transaction in last 365 days. Write a PL/SQ block (using implicit cursor) to update the status of account, display an approximate message based on the no. of rows affected by the update.(Use of %FOUND, %NOTFOUND, %ROWCOUNT)

SQL> SELECT * FROM account_b123;
    ACC_NO NAME       STATUS
---------- ---------- ----------
       123 Avi        active
       122 Aadi       active
       129 Harshad    active
       121 Atharva    active
       125 Kalayni    inactive
       126 Aish       inactive
6 rows selected.



SQL> BEGIN
  2  UPDATE account_b123 SET status = 'active' WHERE status = 'inactive';
  3  dbms_output.put_line(SQL%ROWCOUNT||' no of account updated');
  4  END;
  5  /
2 no of account updated
PL/SQL procedure successfully completed.
SQL> SELECT * FROM account_b123;
    ACC_NO NAME       STATUS
---------- ---------- ----------
       123 Avi        active
       122 Aadi       active
       129 Harshad    active
       121 Atharva    active
       125 Kalayni    active
       126 Aish       active
6 rows selected.
SQL> BEGIN
  2  UPDATE account_b123 SET status = 'active' WHERE status = 'inactive';
  3  dbms_output.put_line(SQL%ROWCOUNT||' no of account updated');
  4  END;
  5  /
0 no of account updated

EXPLICIT CURSOR:
2. Organization has decided to increase the salary of employees by 10% of existing salary, who are having salary less than average salary of organization, Whenever such salary updates takes place, a record for the same is maintained in the increment_salary table.
EMP (E_no , Salary) increment_salary(E_no , Salary)

SQL> SELECT * FROM salary_b123;
    EMP_NO     SALARY
---------- ----------
       121      11000
       122      22000
       123      30000
       124      40000
       125      50000

SQL> DECLARE
  2  CURSOR salhigh IS SELECT emp_no,salary FROM salary_b123 WHERE salary < (SELECT AVG(salary) FROM salary_b123);
  3  memp_no salary_b123.emp_no%type;
  4  msalary salary_b123.salary%type;
  5  BEGIN
  6  OPEN salhigh;
  7  IF salhigh%isopen THEN
  8  LOOP
  9  fetch salhigh into memp_no,msalary;
 10  exit when salhigh%notfound;
 11  if salhigh%found then
 12  update salary_b123 set salary = (0.1*msalary+ msalary) WHERE emp_no = memp_no;
 13  insert into increment_salary_b123 values(memp_no,0.1*msalary+ msalary);
 14  end if;
 15  end loop;
 16  end if;
 17  Close salhigh;
 18  END;
 19  /
PL/SQL procedure successfully completed.

SQL> SELECT * FROM salary_b123;
    EMP_NO     SALARY
---------- ----------
       121      12100
       122      24200
       123      33000
       124      40000
       125      50000




SQL> SELECT * FROM increment_salary_b123;
    EMP_NO INCREMENT_SALARY
---------- ----------------
       121            12100
       122            24200
       123            33000


3. Write PL/SQL block using explicit cursor for following requirements:
College has decided to mark all those students detained (D) who are having attendance less than 75%. Whenever such update takes place, a record for the same is maintained in the D_Stud table. create table stud21(roll number(4), att number(4), status varchar(1));
create table d_stud(roll number(4), att number(4));

SQL> SELECT * FROM stud_b123;
   ROLL_NO        ATT S
---------- ---------- -
       121         90
       122         74
       123         50
       124        100
       125         10




SQL> DECLARE
  2  CURSOR check_status IS SELECT roll_no,att FROM stud_b123 WHERE att < 75 ;
  3  mroll_no stud_b123.roll_no%type;
  4  matt stud_b123.att%type;
  5  BEGIN
  6  OPEN check_status;
  7  IF check_status%isopen THEN
  8  LOOP
  9  FETCH check_status INTO mroll_no,matt;
 10  exit WHEN check_status%notfound;
 11  IF check_status%found THEN
 12  UPDATE stud_b123 SET status = 'D' WHERE roll_no = mroll_no;
 13  INSERT INTO d_stud_b123 VALUES(mroll_no,matt);
 14  END IF;
 15  END LOOP;
 16  END IF;
 17  CLOSE check_status;
 18  END;
 19  /

PL/SQL procedure successfully completed.



SQL> SELECT * FROM stud_b123;

   ROLL_NO        ATT S
---------- ---------- -
       121         90
       122         74 D
       123         50 D
       124        100
       125         10 D

SQL> SELECT * FROM d_stud_b123;

   ROLL_NO        ATT
---------- ----------
       122         74
       123         50
       125         10



















Assignment No.7

Output
1.Write a update, delete trigger on clientmstr table. The System should keep track of the records that ARE BEING updated or deleted. The old value of updated or deleted records should be added in the audit_trade table. (separate implementation using both row and statement triggers)
SQL> CREATE OR REPLACE TRIGGER trade_record_b123
  2  AFTER INSERT OR DELETE
  3  ON client_b123
  4  FOR EACH ROW
  5  DECLARE
  6      op VARCHAR(10);
  7  BEGIN
  8      IF updating THEN
  9      op:='update';
 10      END IF;
 11      IF deleting THEN
 12      op:='Delete';
 13      END IF;
 14      INSERT INTO trade_b123 VALUES(:old.c_id,:old.p_amt,op);
 15  END;
 16  /
Trigger created.

SQL> SELECT * FROM client_b123;
      C_ID      P_AMT
       ---------- ----------
       121       1500
       122       1500
       123       1500
       124       1500
       125       3000

SQL> SELECT * FROM trade_b123;
no rows selected

SQL>
SQL> CREATE OR REPLACE TRIGGER trade_record_b123
  2  AFTER UPDATE OR DELETE
  3  ON client_b123
  4  FOR EACH ROW
  5  DECLARE
  6      op VARCHAR(10);
  7  BEGIN
  8      IF updating THEN
  9      op:='update';
 10      END IF;
 11      IF deleting THEN
 12      op:='Delete';
 13      END IF;
 14      INSERT INTO trade_b123 VALUES(:old.c_id,:old.p_amt,op);
 15  END;
 16  /
Trigger created.

SQL> SELECT * FROM client_b123;
      C_ID      P_AMT
---------- ----------
       121       1500
       122       1500
       123       1500
       124       1500
       125       3000

SQL> SELECT * FROM trade_b123;
no rows selected

SQL> UPDATE client_b123 SET p_amt = 1000  WHERE p_amt=1500;
4 rows updated.
SQL> SELECT * FROM trade_b123;
      C_ID      P_AMT STATUS
---------- ---------- ----------
       121       1500 update
       122       1500 update
       123       1500 update
       124       1500 update

SQL> CREATE OR REPLACE TRIGGER trade_record_b123
  2  AFTER UPDATE OR DELETE
  3  ON client_b123
  4  DECLARE
  5      op VARCHAR(10);
  6  BEGIN
  7      IF updating THEN
  8      op:='update';
  9      END IF;
 10      IF deleting THEN
 11      op:='Delete';
 12      END IF;
 13      INSERT INTO trade_b123 VALUES(:old.c_id,:old.p_amt,op);
 14  END;
 15  /
CREATE OR REPLACE TRIGGER trade_record_b123
                         *
ERROR at line 1:
ORA-04082: NEW or OLD references not allowed in table level triggers

SQL> CREATE TABLE trade_status_b123(
  2      status VARCHAR(10)
  3  );
Table created.

SQL> CREATE OR REPLACE TRIGGER trade_record_b123
  2  AFTER UPDATE OR DELETE
  3  ON client_b123
  4  DECLARE
  5      op VARCHAR(10);
  6  BEGIN
  7      IF updating THEN
  8      op:='update';
  9      END IF;
 10      IF deleting THEN
 11      op:='Delete';
 12      END IF;
 13      INSERT INTO trade_status_b123 VALUES(op);
 14  END;
 15  /
Trigger created.
SQL> SELECT * FROM client_b123;
      C_ID      P_AMT
---------- ----------
       121       1000
       122       1000
       123       1000
       124       1000
       125       3000

SQL> UPDATE client_b123 SET p_amt = 1500 WHERE p_amt=1000;
4 rows updated.
SQL> SELECT * FROM trade_status_b123;

STATUS
----------
Update  


2. Write a before trigger for Insert, update event considering following requirement:
Emp(e_no, e_name, salary)
I) Trigger action should be initiated when salary is tried to be inserted is less than Rs.
50,000/-
II) Trigger action should be initiated when salary is tried to be updated for value less
than Rs. 50,000/-
Action should be rejection of update or Insert operation by displaying appropriate error
message. Also the new values expected to be inserted will be stored in new table
Tracking(e_no, salary).

SQL> SELECT * FROM employee_b123;
no rows selected
SQL> SELECT * FROM emp_sal_b123;
no rows selected



SQL> CREATE OR REPLACE TRIGGER emp_sal_record
  2  BEFORE UPDATE OR INSERT
  3  ON employee_b123
  4  FOR EACH ROW
  5  DECLARE
  6      sal NUMBER:=:new.salary;
  7  BEGIN
  8      IF sal < 50000 THEN
  9          IF updating THEN
 10              raise_application_error(-20003,'This update opration violet comapany rule / record not inserted');
 11          END IF;
 12          IF inserting THEN
 13              raise_application_error(-20003,'This insert opration violet comapany rule / record not inserted');
 14          END IF;
 15      ELSE
 16          DBMS_OUTPUT.PUT_LINE('Record created successfully');
 17          INSERT INTO emp_sal_b123 VALUES(:new.e_no,:new.salary);
 18      END IF;
 19  END;
 20 /
Trigger created.
SQL> INSERT INTO employee_b123 VALUES(123,'Aviraj',100000);
Record created successfully
1 row created.

SQL> INSERT INTO employee_b123 VALUES(124,'Ankit',1000);
INSERT INTO employee_b123 VALUES(124,'Ankit',1000)
            *
ERROR at line 1:
ORA-20003: This insert opration violet comapany rule / record not inserted
ORA-06512: at "SYSTEM.EMP_SAL_RECORD", line 9
ORA-04088: error during execution of trigger 'SYSTEM.EMP_SAL_RECORD'

SQL> UPDATE employee_b123 SET salary = 1000 WHERE e_no =123;
UPDATE employee_b123 SET salary = 1000 WHERE e_no =123
       *
ERROR at line 1:
ORA-20003: This update opration violet comapany rule / record not inserted
ORA-06512: at "SYSTEM.EMP_SAL_RECORD", line 6
ORA-04088: error during execution of trigger 'SYSTEM.EMP_SAL_RECORD'

3. Write a Database trigger for the following requirements: Employee salary of last three months is stored in the emp_sal table. emp_sal(emp_no, sal1,sal2,sal3) before inserting salary into emp_sal table, if salary of an employee in any of the last three months is greater than Rs. 50,000/- then entry of average salary along with emp_no needs to be inserted into new table emp_new(emp_no, avg_sal).

SQL> SELECT * FROM emp_sal_b123;
no rows selected
SQL> SELECT * FROM emp_avg_b123;
no rows selected


SQL> CREATE OR REPLACE TRIGGER emp_sal_track
  2  BEFORE INSERT
  3  ON emp_sal_b123
  4  FOR EACH ROW
  5  BEGIN
  6      IF (:new.sal_one > 50000 OR :new.sal_two > 50000 OR :new.sal_three > 50000) THEN
  7          INSERT INTO emp_avg_b123 VALUES(:new.e_no,((:new.sal_one + :new.sal_two + :new.sal_three)/3));
  8          DBMS_OUTPUT.PUT_LINE('Record added to emp_sal and emp_avg successfully');
  9      ELSE
 10          DBMS_OUTPUT.PUT_LINE('Record added to emp_sal successfully');
 11      END IF;
 12  END;
 13  /
Trigger created.

SQL> INSERT INTO emp_sal_b123 VALUES(123,100000,100000,100000);
Record added to emp_sal and emp_avg successfully
1 row created.
SQL> INSERT INTO emp_sal_b123 VALUES(199,100,100,100);
Record added to emp_sal successfully
1 row created.



SQL> SELECT * FROM emp_sal_b123;
      E_NO    SAL_ONE    SAL_TWO  SAL_THREE
---------- ---------- ---------- ----------
       123     100000     100000     100000
       199        100        100        100
SQL> SELECT * FROM emp_avg_b123;
      E_NO    AVG_SAL
---------- ----------
       123     100000


















